# 운영체제 스터디 7주차 정리

chapter 6. 동기화 도구들

여러 프로세스가 공유하는 데이터에서 무결성 문제가 발생할 수 있음.

유한 버퍼를 사용하는 경우

동시에 최대 BUFFER_SIZE - 1개까지의 항목만 버퍼에 저장할 수 있음.

→ 이를 해결하기 위해 count라는 정수형  변수를 추가

→ but 병행적으로 수행시키면 올바르게 동작하지 않음.

레지스터의 연산 순서에 따라 count 값의 원자성이 보장되지 않음.

```jsx
register1 = count
register1 = register1 + 1
count = register1

=> 마지막 동작 전에 register2 에서의 동작이 실행될 수 있음.
```

race condition(경쟁 상태): 결과가 실행 순서에 따라 변경될 수 있는 상태

## 임계구역 문제

```jsx
1. entry section (진입 구역)
2. critical section (임계 구역)
3. exit section (퇴출 구역)
4. remainder section (나머지 구역)
```

임계구역(critical section): 적어도 하나 이상의 다른 프로세스와 공유하는 데이터에 접근하고 갱신할 수 있는 코드 부분

- 한 프로세스가 자신의 임계구역에서 수행하는 동안에는 다른 프로세스들이 그 임계구역에 들어갈 수 없음.

### 임계구역 문제를 해결하기 위한 요구 조건

1. 상호 배제(mutual exclusion): 한 프로세스가 자신의 임계구역에서 실행된다면, 다른 프로세스들은 그들 자신의 임계구역에서 실행될 수 없다.
2. 진행(progress): 자신의 임계구역에서 실행되는 프로세스가 없는 상태에서 자신의 임계구역으로 진입하려고 하는 프로세스들이 있다면, remainder section에서 실행중이지 않은 프로세스들만 임계구역에 진입할지 결정할 수 있다. 이 선택은 무한정 연기될 수 없다.
3. 한정된 대기(bounded waiting): 프로세스가 임계구역에 진입 요청을 한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 그들 자신의 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다.

## Peterson Solution

고전적인 소프트웨어 기반 해결책으로 현대 컴퓨터 구조에 실제로 적용은 어려움.

임계구역과 나머지 구역을 번갈아 가며 실행하는 두 개의 프로세스로 한정

- 각 프로세스: pi, pj

두 개의 데이터 항목을 공유

```c
int turn;          // 임계구역으로 진입할 순번
boolean flag[2];   // 프로세스가 임계구역으로 진입할 준비가 되었다는 것을 나타냄.
```

- turn == i 이면 pi 가 임계구역에서 실행될 수 있음.
- flage[i] == ture 이면 pi가 임계구역으로 진입할 준비가 되었다는 것

```c
while (true) {
	flag[i] = true;
	turn = j;
	while (flag[j] && turn == j) // wait
	
	// pi가 critical section 진입
	
	flag[i] = false;
	
	// remainder section
}
```

1. pi 가 임계구역으로 진입하기 위해선 flag[i]를 참으로 만들고, turn을 j 로 지정
2. 임계구역에 들어가고자 하는 다른 프로세스가 있다면 자신의 순서를 기다리기 위해 `flag[i] && turn == i` 가 아니라 j의 순서인지를 확인

⇒ “1. 상호 배제”가 지켜짐.

> (제가 이해한 내용) 만약 pi가 while 조건으로 flage[i] && turn == i 를 사용했다면 자신이 변경한 값을 while 조건에서 그대로 사용하게 되므로 race condition 이 그대로 발생하게 됨.
>

pi가 flag[i] 를 true 로 변경하고 나고나서 while 문에서 pj 가 실행되는 동안 대기하게 됨.

→ pj 도 flag[j] 를 true로 변경하고 while에 들어가게 된다면 pi, pj 의 race condition에 상관없이 turn이 i, j 둘 중 하나로 설정되기 때문에 하나의 프로세스가 실행되게 됨.

→ 먼저 실행됨 프로세스가 끝나면 나오면서 다른 turn을 다른 프로세스로 바꿔주기 때문에 다른 프로세스가 임계구역에 진입하게 됨.

⇒ “2. progress 보장”과 “3. 대기 시간이 유한함”이 지켜짐.

## 동기화를 위한 하드웨어 지원

### 1. 메모리 장벽 (메모리 펜스)

\: 컴퓨터 아키텍처가 응용 프로그램에게 제공하는 메모리에 접근 시 보장되는 사항을 결정하는 방식

→ 컴퓨터 아키텍처가 메모리의 모든 변경 사항을 다른 모든 프로세서로 전파하는 명령어를 제공

- 강한 순서: 메모리 변경 결과를 다른 모든 프로세서에 즉시 보임.
- 약한 순서: 즉시 보이지 않음.

```c
x = 100;
memory_barrier(); // 메모리 장벽
flag = true;
```

### 2. 하드웨어 명령어

\: 한 word의 내용을 검사하고 변경하거나 두 word의 내용을 원자적으로 교환할 수 있는(인터럽트 되지 않는 하나의 단위) 특별한 하드웨어 명령어를 제공함.

- test_and_set(): 원자적으로 실행되어, 이 명령어가 동시에 실행된다면 임의의 순서로 순차적으로 실행됨.
- compare_and_swap() (CAS): 두 word의 원자적인 연산을 지원하지만 내용 교환에 기반을 둔 다른 기법을 사용

test_and_set()

```c
boolean test_and_set(boolean *target) {
	boolean rv = *target; // target = 전역변수
	*target = true;
	
	return rv;
}
```

```c
do {
	while (test_and_set(&lock)) // 대기
	
	// critical section
	
	lock = false;
	
	// remainder section
} while (true);
```

compare_and_swap()

```c
int compare_and_swap(int *value, int expected, int new_value) {
	int temp = *value;
	
	if (*value == expected)
		*value = new_value;
	
	return temp;
}
```

```c
while (true) {
	while (compare_and_swap(&lock, 0, 1) !== 0) // 대기
	
	// critical section
	
	lock = 0;
	
	// remainder section
}
```

### 3. 원자적 변수

\: 정수 및 불린과 같은 기본 데이터 유형에 대한 원자적 연산을 제공 → 종종 CAS 를 사용해 구현

```c
void increment(atomic_int *v) {
	int temp;
	
	do {
		temp = *v;
	} while (temp != compare_and_swap(v, temp, temp + 1));
}
```

- 원자적 갱신은 제공하지만, 모든 상황에서 경쟁 조건을 완벽히 해결하진 않는다.

## Mutex Lock

\: 프로세스가 임계구역에 들어가기 전에 반드시 락을 획득해야 하고, 임계구역을 빠져나올 때 락을 반환해야 함.

```c
while (true) {
	acpuire lock
	
	// critical section
	
	release lock
	
	// remainder section
}
```

→ busy waiting(spinlock)을 해야 한다는 단점이 있음.

> (참고) spinlock은 CPU를 낭비하게 되지만 짧은 대기인 경우 사용하면 컨텍스트 스위칭 비용을 아낄 수 있음.
>

## Semaphores

\: 정수 변수로서 초기화를 제외하고는 두 개의 표준 원자적 연산 wait(), signal()로만 접근할 수 있음.

```c
wait(S) {
	while (S <= 0) // busy wait
	S--;
}
```

```c
signal(S) {
	S++;
}
```

- Counting Semaphore: 제한 없는 영역(domain)을 가짐.
- Binary Semaphore: 0과 1 사이의 값만 가능