# 6장. 동기화 도구들
race condition을 방지하기 위해 동기화 문제를 해결해야 한다.

<img width="500" alt="image" src="res/1.png" />

각 프로세스는 각자의 임계구역이 있다.

### 임계구역 문제

프로세스들이 데이터를 공유하기 위해 동기화에 사용하는 프로토콜 설계 ⇒ 임계구역을 어떻게 지킬건지에 대한 프로토콜

### 임계구역 문제 해결안 조건

1. 상호 배제: 하나의 프로세스가 본인의 임계구역을 실행 중이라면 다른 프로세스들은 자신의 임계구역을 실행할 수 없음
2. 진행: 임계구역을 돌리고 있는 프로세스가 없는데도 누가 들어갈지 결정 안나서 멈춰있으면 안되고 계속 진행해야한다~~
3. 한정된 대기: 임계구역 진입 요청을 한 상태라면 다른 프로세스는 임계구역을 진입하는 횟수에 제한을 둬야한다. 다른 프로세스들이 임계구역을 들어가는걸 영원히 기다려줄 수 는 없으니..

커널 자료구조에서는 아래에서 자주 경쟁 조건 발생

- 메모리 할당을 관리하는 자료구조: 여러 군데서 할당 요청이 오니까
- 프로세스 리스트를 유지하는 자료구조: 새 프로세스 생성 요청이 계속 오니까
- 인터럽트 처리를 위한 자료구조: 인터럽트 요청이 여러 군데서 오니까…

## SW기반 해결책 - Perterson 해결안 (현대 아키텍처에서 사용 불가)

<img width="500" alt="image" src="res/2.png" />


공유하는 데이터

1. int turn: 다음으로 진입할 수 있는 프로세스
2. boolean flag[2]: 임계구역 진입할 준비가 된 프로세스

순서

1. flag[i] = true  // i 준비됐음!
2. turn = j // 다음으로는 j 프로세스 진입할 수 있다 (양보의 의미!)
3. 임계구역 작업 중~~
4. flag[j] = true // j 프로세스 준비됐음!
5. i의 while문 종료되어 임계구역 작업 끝
6. flag[i] = false /// i 작업 끝남
7. turn = i // j 프로세스 돌아가면서 다음 실행될 프로세스로 i를 지정

나중에 i 프로세스가 다시 임계구역 들어가고 싶어서 flag[i] = true 다시 본인이 임계구역 탈취할 수 있음

⇒ 한정된 대기

---

하지만 현대 아키텍쳐에서는 정확히 프로세서가 flag[i] = true 값 처리 후에 turn = j 를 실행하지 않는다. 두 변수간 종속성이 없기 때문에 무엇이 먼저 실제 값이 변경될지는 모르는 것.. (작업 재정렬)

<img width="500" alt="image" src="res/3.png" />

1. 프로세스 i가 임계구역 실행 중에(flag[i] == true, turn == j 상태)
2.  j프로세스가 실행되어 turn 이 먼저 i로  바뀌고 (flag[i] == true, turn == i라서 여전히 i는 임계구역 실행)
3. flag[j] = true 값 세팅된 후에 j 도 임계구역 진입~ (flag[j] == true, turn == i라서 여전히 i는 임계구역 실행)

⇒ 두 프로세스 모두 임계구역 실행 중.. 상호배제가 지켜지지 않음

⇒ 결국 동기화 도구를 사용해야만 한다.

