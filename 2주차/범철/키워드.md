# 운영체제 스터디 2주차 키워드

API 서버는 어떻게 계속 살아 있고, 요청이 들어오면 반응하는 구조인가?

프로세스 안에서 소켓을 열고 커널에 요청 대기 등록을 한 상태로 sleep함.

1. OS에게 TCP socket listen 요청
2. socket을 특정 포트에 바인딩
3. 포트로 요청이 들어오면 커널이 알려줌.
4. 프로세스는 이벤트 루트(또는 스레드풀)에서 대기

## 요청이 들어왔을 때 어떻게 감지하는지?

### TCP 수준에서의 흐름

1. 클라이언트가 서버의 IP:PORT로 TCP SYN 패킷 전송

    ```
    SYN -> SYN-ACK -> ACK
    ```

2. 커널이 이 연결을 소켓 대기열(listen queue)에 추가
3. 커널이 해당 소켓을 “readable” 상태로 마킹
4. 서버 프로세스가 accept() 또는 epoll_wait() 호출 상태였다면 즉시 깨워짐
5. 서버가 해당 연결을 “accept”하고, 응답 처리 스레드/이벤트로 전달

### Node.js 기준 (libuv + epoll)

libuv 라이브러리를 사용해 커널 이벤트를 감시

```
Node.js Process
- Event Loop
- HTTP Server
- libuv (epoll, kqueue)
```

- epoll(Linux) 또는 kqueue(macOS)를 통해 커널에 “소켓 감시” 등록
- 커널이 “새 연결 있음” 이벤트 발생 시 epoll_wait() return
- libuv가 콜백 실행 → 이벤트 루프에 전달
- Node.js가 createServer()에 등록된 콜백 실행

→ Node.js는 busy loop로 돌고 있는 것이 아니라, 커널 이벤트를 기다리다가 깨워지는 구조

### Spring Boot (Tomcat) 기준

```
Tomcat ServerSocket
-> OS 커널 listen queue
-> acceptor thread
-> worker thread pool
-> Spring Controller 호출
```

- ServerSocketChannel을 열고 OS에 “포트 감시” 요청
- 내부적으로 Selector.select()로 커널 이벤트 대기
- 커널에서 ”읽을 준비됨” 이벤트 발생 → 톰캣의 acceptor 스레드 깨움
- worker thread가 요청을 받아 Spring Controller에 전달

## 요청이 없을 때의 상태

- Node.js: 이벤트 루프가 epoll_wait() 상태로 블락 중
- Spring Boot: Tomcat의 Selector.select()가 블락 중
- CPU 사용량은 거의 없고, 프로세스는 sleep 상태지만 OS가 소켓 이벤트를 감시 중