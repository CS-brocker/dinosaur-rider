# 운영체제 스터디 2주차 강의 정리

강의 섹션 3 1~2파트

## Process
실행중인 프로그램

- OS에서 작업의 단위
- CPU time, memory, file, I/O 디바이스 사용

→ OS는 프로세스를 관리하는 일을 해야 함.

## Memories of Process

![img.png](res/img1.png)

- Text section
- Data section
- Heap section
- Stack section

## States of Process

- New
- Running
- Waiting
- Ready
- Terminated

![img.png](res/img2.png)

## PCB(Process Control Block)

또는 TCB(Task Control Block)

: 프로세스가 가져야 하는 정보들을 저장

- 저장되는 정보들
    - Process state
    - Program counter
    - CPU registers
    - CPU-scheduling info
    - Memory-management info
    - Accounting info
    - I/O status info

![img.png](res/img3.png)

## Multi Process

- CPU를 효율적으로 사용하기 위함.

### Scheduling Queue

- ready queue
- wait queue

### Context Switch
process 의 state 가 변경되는 것

- context 는 PCB에 저장됨.
- CPU를 다른 프로세스에 할당해주는 것
    - 기존 프로세스의 state 를 저장하고, 다른 프로세스의 state 를 restore 함.

## Tree of Process

![img.png](res/img4.png)

- 프로세스 실행 방법
    - parent, children 이 동시에 실행
    - children이 terminated될 때 까지 parent가 wait.t

- address-space 복제
    - parent 를 복제
    - 새로운 프로그램을 로드

### Orphan process
parent process 가 wait 하지 않고 terminate 됨.

### Zombie process
child process 가 terminate 됐지만, parent process 가 아직 wait 이 아님.

## UNIX like OS

- fork()로 프로세스 생성
- child 프로세스는 parent 프로세스의 address space를 복사
- fork()의 return
    - child process: 0
    - parent process: 0이 아닌 child process의 pid

<예제 1>

![img.png](res/img5.png)

- 결과
  Parent: value = 5
- child process의 value가 처음에는 parent process와 같은 메모리를 공유하지만, 데이터를 바꾸려하는 시점에 복사되어 child process의 PCB에 별도로 저장됨.
  → child process와 parent process의 전역 변수 값 자체를 공유하지는 않음.

<예제 2>

![img.png](res/img6.png)

- 결과
  8개
- 맨 처음: 1개
    - 1번 fork(): 2개
        - 2번 fork(): 4개
            - 3번 fork(): 8개

---

## 프로세스간 통신 (IPC, Inter-Process Communication)

- 프로세스가 독립적으로 실행되면 문제 없지만, 협력적으로 실행되면 문제가 생김.
- independent(독립적)
  - 프로세스끼리 아무런 데이터도 주고받지 않음.
- cooperationg
  - 프로세스끼리 데이터를 주고받음.

### shared memory

### message passing

- 운영체제에게 맡김.

### Producer-Consumer Problem

- shared memory
  - producer 는 buffer를 채우고, consumer 는 buffer를 비움.
    - bounded buffer인 경우 buffer가 가득 차면 producer는 wait.
    - buffer가 비어 있다면 consumer는 wait.
  - 프로세스끼리는 서로 독립된 메모리 영역을 가지고 있기 때문에 shared memory 영역이 별도로 존재하며, 이는 os가 관리함.
  - shared memory를 애플리케이션 프로그래머가 직접 관리해야 함.

- message Passing
  - OS가 cooperation process들에게 데이터 전달 방법을 제공하는 것
  - Communication Link
    - 프로세스끼리 커뮤니케이션할 수 있또록 메시지를 send, receive 하는 기능을 제공
    - direct 또는 indirect communication
    - synchronous 또는 asynchronous communication
    - automatic 또는 explicit buffering

## Message Passing

### direct communication

- 발송자 또는 수신자를 명시적으로 입력해야 함.
- Link는 자동적으로 생성됨.
- link는 두 프로세스 간에 정확히 하나만 존재

### indirect communication

- mailbox(또는 port)에 message 를 보내고 받음.
- 발송자 또는 수신자를 명시하지 않고, mailbox 이름만 명시하면 됨.
- 두 프로세스가 모두 shared mailbox로 데이터를 주고 받았을 때 link가 생성됨.
- 하나의 link 는 여러 개의 프로세스와 연관될 수 있음.
- OS가 프로세스에 제공해야 하는 것
  - mailbox 생성
  - mailbox에 메시지를 전송, 수신
  - mailbox 삭제

### blocking (synchronous)

- send
  : 프로세스가 데이터를 전송하면 그 데이터가 모두 전송될 때까지 대기
  - receive
  : 메시지를 모두 받을 때까지 대기

### non-blocking(asynchronous)

- send
  : 프로세스가 보낼 데이터를 os에 던져버리고 다음 동작을 하고 os에서 데이터를 모두 전송해주는 역할을 함.
  - receive
  : valid message 또는 null message 를 수신하고 다른 동작을 계속함.

### IPC 시스템의 예시

- shared memory: POSIX Shared Memory
- message passing: Pipes

### POSIX shared memory

- memory-mapped file을 사용

### Pipies

- unidirectional, bidirectional
- half-duplex, full-duplex
- relationship
- network에서 커뮤니케이션 할 것인가?

## 네트워크를 통한 커뮤니케이션

### Sockets

- 네트워크를 통해 다른 컴퓨터와 연결하기 위함.

### RPCs(Remote Procedure Calls)