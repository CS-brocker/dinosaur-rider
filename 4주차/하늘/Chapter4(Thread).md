### 다중 스레드 프로그래밍 이점

- 응답성: 이미 프로그램이 긴 작업을 수행 중이더라도 프로그램의 수행을 계속되도록 해서 사용자의 응답성을 증가시킨다.
- 자원 공유, 경제성: 자동으로 코드, 데이터 섹션, 파일 등을 공유하기 때문에 공유 메모리나 메시지 전달 기법을 쓰지 않아도되어 오버헤드가 적고 빠르다.
- 규모 적응성: 하나의 스레드는 다중처리기가 있어도 하나의 처리기만 사용하게 되지만 여러 스레드를 다중처리기로 돌리면 병렬로 처리할 수 있다.

### Amdahl’s Law

코어를 추가했을 때 성능 향상은 코어의 수와 비례하지 않는다

### 암묵적 스레딩

스레딩 생성과 관리 책임은 컴파일러와 런타임 라이브러리에게 넘기는 방식

런타임 라이브러리는 다대다모델을 사용하여 별도의 스레드에 매핑된다.

### 스레드 풀

프로세스를 시작할 때 일정한 수의 스레드를 미리 만들어둔다.

스레드를 생성할 때마다 소요되는 시간을 단축할 수 있다.

### fork() & exec()

- fork() → 프로세스를 복제
- 어떤 OS는 스레드까지 **모두 **복제
- 어떤 OS는 호출한 **스레드만 **복제
- exec() → 현재 프로세스를 새 프로그램으로 교체 (스레드는 모두 사라짐)

## 신호(Signal) 처리

신호는 프로세스에 이벤트를 알리는 방법

단일 스레드에서는 단순하지만 멀티스레드에서는 어느 스레드가 신호를 받을지 결정해야 함

선택지:

1. 특정 스레드에게만 전달
2. 모든 스레드에게 전달
3. 일부 스레드에게만 전달
4. 특정 스레드가 모든 신호를 받도록 지정

### 스레드 취소(Thread Cancellation)

비동기 취소: 즉시 죽임 (위험, 자원 누수 가능)

지연 취소: 스레드가 스스로 취소 가능한 지점에서 종료(안전)

## 스케줄러 액티베이션(Scheduler Activations)

- 다대다(M:N) 스레딩 모델에서 사용자 스레드 ↔ 커널 스레드 간 통신 방식
- LWP(Lightweight Process) = 사용자 스레드를 위한 가상 CPU
- 여러 사용자 스레드는 하나의 LWP에 매핑될 수 있음
- 필요하면 LWP를 여러 개 요청해 CPU 병렬성을 높임
- Upcall: 커널이 사용자 스레드 라이브러리에게 “이벤트 발생했어”라고 알려주는 메커니즘
- 예: LWP가 블록됨 → 커널이 upcall → 라이브러리가 다른 스레드를 실행함
