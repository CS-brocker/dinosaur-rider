# 운영체제 스터디 4주차 키워드

# Node.js의 Process

기본적인 Node.js 앱 하나는 하나의 프로세스로 구동됨.

- 멀티코어를 제대로 활용하기 위해선 프로세스를 여러 개 띄우는 걸 권장
    - cluster 모듈
        - 마스터 프로세스 + 워커 프로세스 여러 개
        - 각 워커는 독립적인 Node 프로세스
        - 보통 CPU 코어 수만큼 워커를 띄워서 HTTP 서버를 병렬 처리
    - child_process.fork()
        - 별도 Node 프로세스를 실행해서 부모-자식 간 IPC로 통신

## cluster 모듈

Node.js에서 멀티 코어를 제대로 쓰려면 Node 프로세스를 여러 개 띄워서 같은 포트로 들어오는 요청을 여러 프로세스가 나눠 처리하게 하는 구조가 필요함.

→ cluster 모듈이 마스터 + 워커 구조로 쉽게 만들어줌.

- 마스터 프로세스
    - 워커 프로세스들을 fork 해서 띄우고 관리
    - HTTP 서버 핸들(소켓)을 워커에게 나눠주는 역할
- 워커 프로세스
    - 실제로 http.createServer 등 서버 로직을 수행
    - 각각 독립된 Node 프로세스 (PIC 다름, 힙/이벤트 루프도 다름)

### 공유 안되는 것

- 각 워크는 완전 독립적인 프로세스
    - JS 힙, 이벤트 루프, 모듈 캐시, 변수… 전부 각자 따로
    - global, in-memory cache, 연결 풀 등도 워커마다 따로

→ 메모리 캐시를 쓰거나 세션을 메모리에만 저장하면 문제가 발생할 수 있음.
→ Redis 같은 외부 저장소 활용

### 간접적으로 공유되는 것

- 리스닝 포트
    - OS 레벨에선 하나지만, Node가 내부에서 이 핸들을 워커들에 나눠줘서 들어오는 요청을 라운드로빈 등으로 분배
- IPC
    - worker.send(), process.on(’message’)로 마스터 ↔ 워커 간 메시지 주고받기 가능
    - 메모리 공유가 아니라 메시지 기반 통신

---

# Node.js의 Thread

## JavaScript

“메인 JS 코드”를 실행하는 스레드(Event Loop)는 1개 → 기본적으로 싱글 스레드에서 순차적으로 실행됨.

- 공유 메모리에 대한 race condition, 뮤텍스를 고민할 일이 적음.
- 대신 이벤트 루프 + 콜백/Promise/async-await 구조로 비동기 처리

## 실제로는…

- (전에 pstree 확인한 것처럼) Node.js 내부에는 메인 스레드 이 외의 libuv 스레드 풀(기본 4개)과 기타 스레드들이 있음.
- 파일 I/O, DNS, 일부 crypto(암호화) 작업 등 블로킹 I/O를 이 스레드 풀에서 처리

⇒ 한 스레드에서 논리만 실행하고, 무거운 I/O는 내부 스레드들이 대신 처리 후 끝나면 콜백/Promise로 결과만 받아옴.

⇒ JS 실행 자체는 싱글 스레드, but 실제 런타임 내부에서는 멀티 스레드 구조

### 메인 스레드 (Event Loop)

- JS 코드가 실행되는 스레드
- 이벤트 루프 + 콜스택 + 콜백 큐 구조
    - HTTP 요청 콜백
    - fs 비동기 콜백
    - setTimeout, Promise microtask 등이 이 안에서 순차적으로 처리됨.

### libuv 스레드 풀

- Node 내부에서 I/O, CPU 일부를 대신 처리해 주는 네이티브 스레드 집합
- 기본 크기: 4 (최대 128까지 설정 가능)
- 주요 처리 작업
    - fs 모듈의 많은 작업 (비동기 파일 I/O)
    - DNS lookup (dns.lookup)
    - 일부 crypto(암호화/복호화) 연산
- 비동기 함수 호출 → 내부 스레드가 처리 → 끝나면 콜백 Promise resolve

---

## 이벤트 루프

한 개의 JS 스레드가 일을 차례대로 꺼내서 콜백을 실행해 주는 반복 루프
→ Node.js가 싱글 스레드인데도 많은 비동기 작업을 처리할 수 있는 핵심

- I/O 같이 긴 작업들은 백그라운드(libuv + OS)에 맡김.
  → JS 메인 스레드는 “끝났다”라는 이벤트를 기다림.
  → 콜백/Promise 핸들러만 실행하는 역할에 집중

```
while (프로세스가 살아 있는 동안) {
	1. 끝난 I/O, 만료된 타이머, 준비된 작업이 있는지 확인
	2. 있으면 그에 대응하는 콜백을 꺼냄
	3. 메인 스레드에서 그 콜백(JS 함수)을 실행
}
```

### 정리

- 콜백/Promise 핸들러는 항상 메인 스레드에서 실행됨.
- libuv 스레드풀이나 OS는 I/O 작업만 대신 처리하고, JS 코드를 직접 실행하지는 않음.

⇒ CPU 바운드 작업(암호화/복호화, 파일 처리)을 오래 돌리면 이벤트 루프가 막혀서 다른 요청들을 못 받을 수 있음.