# 운영체제 스터디 5주차 키워드

# Linux 커널의 CPU 스케줄러

> 각 CPU마다 runqueue를 하나씩 들고 있고, 거기서 다음에 돌릴 태스크를 뽑아 쓰는 구조
>

## 핵심 포인트

- per-CPU runqueue
    - 각 CPU마다 자체 runqueue가 있고 여기 안에는 “지금 이 CPU에서 돌 수 있는 태스크들”이 들어 있음.
- 스케줄링 클래스(sched_class)
    - STOP > DEADLINE > REALTIME(SCHED_FIFO/RR) > CFS(SCHED_OTHER/BATCH) > IDLE 같은 클래스가 있음. → 대략적으로 이 순서로 우선순위를 가짐.
    - 각 클래스가 “자기 클래스 태스트 중 누구를 고를지” 알고리즘을 구현
- 커널의 sschedule() 함수
    1. 현재 태스크가 끝났거나, Sleep했거나, 선점 필요하면 호출
    2. 각 sched_class를 우선순위 높은 순으로 훑으면서 실행 가능한지 물어봄.
    3. 제일 먼저 실행 가능하다고 답한 클래스에서 태스크 하나를 가져와 실행

## CFS(Completely Fair Scheduler)

일반 프로세스용 → 평범한 유저 프로세스 대부분이 CFS 클래스에서 돌게 됨.

- Node.js 서버, Sptin, Pythono 스크립트, CLI 툴 등이 여기서 실행됨.

- 모든 태스크가 CPU를 공정하게 나눠 가지게 하기 위함.
- 각 태스크가 지금까지 CPU를 얼마나 받았는지(vruntime)를 추적
  → 가장 적게 받은 태스크를 다음에 실행

### 핵심 데이터 구조: 레드블랙 트리 + vruntime

- 각 CPU의 runqueue 내부
    - CFS 태스크들은 레드블랙 트리에 들어 있고, key는 vruntime
        - key: 레드블랙 트리에서 정렬의 기준이 되는 값

### 동작 방식

- vruntime
    - 실제로 사용한 CPU 시간을 우선순위(nice)로 스케일링한 값
    - vruntime = (실제 실행한 시간 / weight) 과 같이 구함.
    - 우선순위 높은 태스크는 같은 실제 시간 동안 돌더라도 vruntime 증가가 더 느림.
    - CFS는 항상 트리에서 vruntime 이 가장 작은(leftmost) 태스크를 골라서 실행

- 실제로 트리에 태스트를 삽입/삭제하는 데에는 O(log N), 다음 태스크 고르기는 O(1)로 가능
  → 다음 태스크는 트리의 가장 왼쪽 노드이기 때문

- CFS 는 고정 타임슬라이스보다는  타임 윈도우를 가짐.
    - sched_latency: 몇 ms 안에 태스크에게 한 번씩 CPU를 주자 같은 개념의 윈도우
    - min_granularity: 개별 태스크에게 주는 최소 실행 시간
- 각 태스크의 weight에 비례해서 이 원도우를 잘게 나눠 타임슬라이스를 배분

→ 태스크가 많아질수록 개별 time_slice는 작아지고, nice가 높은 태스크는 상대적으로 더 자주, 더 길게 실행됨.

### nice 와 priority와의 관계

- nice 값: -20(가장 높은 우선순위) ~ 19(가장 낮은 우선순위)
- 각 nice 값은 특정 weight에 매핑되고 CFS에서 vruntime 을 계산할 때 이 weight이 사용되는 것

## REALTIME(SCHED_FIFO/RR) - 실시간 스케줄링

CFS는 일반작업용이고, 실시간 정책이 따로 있음.

- 오디오/비디오 처리, 통신 장비, 하드 리얼타임에 가까운 작업

### 1. SCHED_FIFO

- 고정 우선순위, 선점형 FIFO
- time slice(time quantum, CPU를 한 태스크에게 얼마나 오래 줄지 정해놓은 최대 시간의 조각) 개념이 없음. → 스스로 voluntary yield 또는 block 하지 않으면 CPU를 계속 사용

### 2. SCHED_RR

- SCHED_FIFO + 라운드 로빈
- 같은 우선 순위의 여러 태스크라면 일정한 시간 동안 벌간아가며 실행
- CFS보다 우선순위가 휠씬 높아서 잘못 쓰면 시스템을 거의 독점할 수 있음.

## **DEADLINE (SCHED_DEADLINE) – EDF + CPU 예약**

- 정말 빡센 실시간 시스템용 태스크 (제어 시스템, 멀티미디어 스케줄링, 로보틱스 등)

- Earliest Deadline First + CPU reservation 기반
- 태스크별로 runtime, period, deadline을 지정
- 이론적으로 가장 강력한 실시간 정책이지만, 설계/튜닝 난이도가 높음.
- 다른 모든 정책보다 우선순위가 높음.

- 개발자가 커널 옵션/권한을 갖고 명시적으로 설정하지 않으면 일반 유저 프로세스가 가는 일은 거의 없음.

## STOP - 스케줄러 내부용 “최고 권한”

- 커널 내부의 스케줄러/CPU 제어용 태스크
- 일반적으로 ps 명령어나 API로 보는 프로세스/스레드가 아닌 커널이 CPU 전체를 잠시 멈춰야 할 때 사용하는 내부용 메커니즘
- 사용자가 건드릴 수 없는 레벨 → 스케줄러가 자신의 안정을 위해 쓰는 최상위 클래스

## **IDLE (SCHED_IDLE) – 남는 시간에만 살짝**

- CPU 가 놀고 있을 때만 돌려도 되는 완전 낮은 우선순위의 작업들
- 개발자가 SCHED_IDLE로 정책을 바꿀 수도 있고, 아주 낮은 백그라운드 작업을 실행시킬 수 있음.