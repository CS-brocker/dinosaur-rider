# 정리
# 운영체제 스터디 5주차 정리

5장 CPU 스케줄링 ~ 5.5까지

### 다중 프로그래밍의 목적

CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 것

- 전형적으로 I/O 요청이 완료되기까지 기다려야 함.
- 또는 다수의 프로세스를 메모리 내에 유지하는 경우

⇒ 운영체제는 CPU를 회수해 다른 프로세스에 할당할 수 있어야 함.

프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성됨.

- CPU 버스트(burst)
- I/O 버스트

### CPU 스케줄러

실행 준비가 되어 있는 메모리 내의 프로세스 중에서 선택해 CPU를 할당함.

- 모든 프로세스는 CPU에서 실행될 기회를 기다리며 대기하고 있다.
- 큐에 있는 레코드들은 일반적으로 프로세스들의 프로세스 제어 블록(PCB)들이다.

### CPU 스케줄링 결정이 필요한 상황

1. “실행 상태 → 대기 상태”로 전환될 때
2. “실행 상태 → 준비 완료 상태”로 전환될 때
3. “대기 상태 → 준비 완료 상태”로 전환될 때
4. 프로세스가 종료할 때

→ 1, 4의 경우 반드시 새로운 프로세스가 선택되어야 한다.

## 스케줄링 방법

### 비선점(협조적)

- 일단 CPU가 한 프로세스에 할당되면 프로세스가 종료하든지 대기 상태로 전환해 CPU를 방출할 때까지 점유한다.
- 커널 구조를 단순하게 만들 수 있다.

### 선점

- 대부분의 최신 OS에서 선점 스케줄링 알고리즘을 사용한다.
- 경쟁 조건을 초래할 수 있다.
- 공유 커널 데이터 구조에 액세스 할 때 경쟁 조건을 방지하기 위해 mutex 락과 같은 기법이 필요하다.

## 디스패처

\: CPU 코어의 제어를 CPU 스케줄러가 선택한 프로세스에 주는 모듈

- 하는 일
    - 프로세스의 문맥을 교환
    - 사용자 모드로 전환
    - 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 점프함.

### 자발적 문맥 교환

\: 현재 사용 불가능한 자원을 요청했기 때문에 프로세스가 CPU 제어를 포기한 경우 발생

### 비자발적 문맥 교환

\: 타임 슬라이스가 만료되었거나 우선순위가 더 높은 프로세스에 의해 선점된 경우와 같이 CPU를 빼앗겼을 때 발생

## 스케줄링의 기준

- CPU 이용률
- 처리량(throughput)
    - 단위 시간당 완료된 프로세스의 개수
- 총처리 시간
    - 프로세스를 실행하는 데 소요된 시간
    - 프로세스의 제출 시간과 완료 시간의 간격
      = 준비 큐에서 대기한 시간 + CPU 에서 실행하는 시간 + I/O 시간
- 대기 시간
    - 준비 큐에서 대기하면서 보낸 시간의 합
    - 프로세스가 실행하거나 I/O를 하는 시간의 양에 영향을 미치지는 않음.
- 응답 시간
    - 하나의 요구를 제출한 후 첫 번째 응답이 나올 때까지의 시간
    - 응답이 시작되는 데까지 걸리는 시간임. 그 응답을 출력하는 데 걸리는 시간은 아님.

## 스케줄링 알고리즘

### 선입 선처리 (FCFS)

\: CPU를 먼저 요청한 프로세스가 CPU를 먼저 할당받음.

- 비선점형
- 평균대기 시간이 길 수 있음.
- 호위 효과: 모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것
  → 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하됨.

### 최단 작업 우선 (SJF)

\: 가장 작은 다음 CPU 버스트를 가진 프로세스에 할당

- 선점형 or 비선점형
- 다음 CPU 버스트의 길이를 알 방법은 없으므로 구현할 수 없음.
  → 다음 CPU 버스트가 이전의 버스트와 길이가 비슷하다고 예측해서 구함.
- 주어진 프로세스 집합에 대해 최소의 평균대기 시간을 가짐. → 최적임을 증명할 수 있음.

### 라운드 로빈 (RR)

\: 시간 할당량에 따라 CPU가 프로세스를 옮겨 다닐 수 있도록 선점이 추가됨.

- 원형 큐를 사용해 구현
- 시간 할당량에 따라 성능 차이가 커짐.

### 우선순위

\: 프로세스마다 우선순위가 있어 CPU는 가장 높은 우선순위를 가진 프로세스에 할당됨.

- 무한 봉쇄(기아 상태)가 발생할 수 있다. → 낮은 우선순위 프로세스들이 CPU를 무한히 대기하는 경우
    - aging을 사용해서 해결 가능하다. → 오래 대기한 프로세스의 우선순위를 증가시켜줌.

### 다단계 큐

\: 하나의 큐를 사용하면 다음 프로세스를 결정하기 위해 O(n)의 검색 시간이 필요함.
→ 우선순위마다 별도의 큐를 두어 검색 시간을 줄일 수 있게 함.

- 각 큐마다, 큐들 간의 스케줄링도 필요하다.

### 다단계 피드백 큐

\: 다단계 큐와 달리 프로세스가 큐들 사이를 이동할 수 있게 하는 것

## 스레드 스케줄링

CPU 상에서 실행되기 위해서 LWP를 통한 간접적인 방식일지라도 사용자 수준 스레드는 궁극적으로 연관된 커널 수준 스레드에 사상되어야 한다.

### 프로세스-경쟁-범위(PCS)

- 스레드 라이브러리는 사용자 수준 스레드를 가용한 LWP상에서 스케줄 함.
  → 동일한 프로세스에 속한 스레들 사이에서 CPU를 경쟁하기 때문에 PCS로 알려져 있음.

- 실제로 CPU 상에서 실행중이라는 것은 스레드 라이브러리가 “사용자 수준 스레드”를 가용한 LWP상에서 스케줄 하는 것이 아닌 운영체제가 LWP의 “커널 스레드”를 물리적인 CPU 코어로 스케줄 하는 것을 필요로 함.

### 시스템-경쟁 범위(SCS)

\: CPU 상에 어느 커널 스레드를 스케줄 할 것인지 결정하기 위해 커널이 사용하는 것

### Pthread 스케줄링

스레드를 생성하면서 PCS 또는 SCS를 지정할 수 있음.

## 다중 처리기 스케줄링

- CPU가 여러 개이면 여러 스레드가 병렬로 실행될 수 있으므로 부하 공유가 가능하다.

### 비대칭 다중 처리

\: 마스터 서버라는 하나의 처리기가 모든 스케줄링 결정과 I/O 처리, 다른 시스템의 활동을 취급하게 함. 다른 처리기는 사용자 코드만 수행

- 하나의 코어만 시스템 자료구조에 접근해 자료 공유가 필요 없으므로 간단하다.
- 마스터 서버가 전체 시스템 성능을 저하할 수 있는 병목이 될 수 있다.

### 대칭 다중 처리 (SMP)

\: 각 프로세서가 스스로 스케줄링 할 수 있음.

- 각 프로세서의 스케줄러가 준비 큐를 검사하고 실행할 스레드를 선택해 스케줄링이 진행됨.

### 다중 코어 프로세서

\: 동일한 물리적인 칩 안에 여러 개의 처리 코어를 장착

- OS 입장에서는 개별적인 논리적 CPU처럼 보이게 됨.

### 부하 균등화

\: SMP 시스템의 모든 처리기 사이에 부하가 고르게 배분되도록 시도함.

- Push 이주: 특정 태스크가 주기적으로 각 처리기의 부하를 검사하고 불균형 상태이면 부하를 분배함.
- Pull 이주: 쉬고 있는 처리기가 바쁜 처리기를 기다리고 있는 프로세스를 pull할 때 발생

### 프로세서 선호도

\: 스레드를 한 프로세서에서 다른 프로세서로 이주시키지 않고 대신 프로세서에서 계속 실행시키면서 warm cache를 이용하려고 하는 것

- 약한 선호도: OS가 동일한 처리기에서 프로세스를 실행시키려고 노력하는 정책을 가지고 있지만 보장하지는 않을때
- 강한 선호도: 프로세스가 자신이 실행될 처리기 집합을 명시할 수 있음.

⇒ 부하 균등과 프로세서 선호도는 서로 상충될 때가 있음.

### 이기종 다중 처리

\: 동일한 명령어 집합을 실행하지만 전력 소비를 유휴 수준으로 저정하는 기능을 포함해 클록 속도, 전력 관리 측면에서 차이가 나는 코어를 사용해 설계함.
