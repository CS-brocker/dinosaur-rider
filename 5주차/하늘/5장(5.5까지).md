### CPU 스케줄링 필요한 상황

1. 한 프로세스가 대기상태로 전환되는 경우 (I/O 요청이나 자식 프로세스가 종료되길 기다리며 wai() 호출시 - 코루틴?)
2. 한 프로세스가 실행 상태에서 준비완료 상태로 전환될 때 (인터럽트 발생시) // CPU 뺏길 때
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환될 때 // CPU 돌려받을 때
4. 프로세스 종료시

### 선점 vs 비선점 스케줄링

- 선점: 다른 우선순위 스레드가 나타나면 CPU를 뺏을 수도 있음 ⇒ data race 발생 가능성 있음!
    - ⇒ 비자발적 문맥교환 발생
- 비선점: 스레드가 스스로 놓을 때까지 CPU 뺏을 수 없음 ⇒ 너무 느림
    - ⇒ 자발적 문맥교환 발생

### 스케줄링 알고리즘 기준

- 🔺CPU 이용률
- 🔺처리량: 단위 시간당 완료된 프로세스 개수
- 🔻총처리 시간: 프로세스 제출 시간-완료시간 (준비큐에서 대기한 시간 + CPU 실행 시간 + I/O 시간)
- 🔻대기 시간: 준비큐에서 대기한 시간
- 🔻응답 시간: 응답시 시작되는데까지 걸리는 시간(출력하는 시간은 포함하지 않음)

### 스케줄링 알고리즘

1. 선입 선처리 알고리즘 (FCFS: First Come First Scheduling)
    - FIFO 큐로 관리. 비 선점형..
    - 짧은 프로세스들이 먼저 처리되지 않고 긴 프로세스가 점유한 것을 기다릴 때 평균 대시시간이 엄청나게 들어나게 되어 호위효과(한 개체가 느리면 전체 그룹을 끌어내리는 현상)
2. 최단 작업 우선 스케줄링 (SJFS: Short Job First Scheduling)
    - 최소의 평균 대기 시간을 가짐. 선점형이 더 평균 대기가 적음
    - 다음 CPU 버스트 길이를 알 방법이 없어서 다음 CPU 버스트가 이전 버스트 길이랑 비슷하다고 기대한다 (지수 평균. 최근 버스트일 수록 큰 가중치를 갖는다)
3. 라운드 로빈 스케줄링 (RR)
    - 정해진 시간 할당량을 갖고 프로세스를 돌리는 것
    - 한번 시간 할당량을 초과하면 프로세스는 선점되고 기존 프로세스는 준비큐로 돌아감
    - 문맥 교환 시간보다 시간 할당량이 커야하지만 너무 크면 선입선처리로 퇴보하니 주의
4. 우선순위 스케줄링
    - SJFS도 이것의 특수케이스로 볼 수 있음 (CPU버스트 타임이 낮은 것이 우선)
    - 기아상태 주의 → aging으로 해결 가능: 오랫동안 대기하는 프로세스의 우선순위를 점차 올리는 것
5. 다단계 큐 스케줄링
    1. 우선순위를 확인할 때마다 O(n)의 검색이 필요할 수 있으니, 우선마다 별도의 큐를 갖는 방식
    2. 일반적으로 프로세스가 큐 사이를 오가는 것을 비허용
6. 다단계 피드백 큐 스케줄링
    1. 프로세스가 큐 사이를 오가는 것을 허용
    2. 프로세스가 CPU를 너무 많이 쓰면 우선순위 낮춤 

### 다중 처리기 스케줄링

**대칭 다중 처리 (SMP: symmetric multi procssing)**

- 각 프로세서(코어)의 스케줄러가 준비큐를 검사하고 실행할 스레드를 선택하여 스케줄링
- 부하 균등화: 모든 큐에 대략 같은 수의 스레드가 있어야 하는 관점 + 모든 큐에 스레드 우선순위를 균등하게 분배해야 한다
1. 모든 스레드가 공통 준비 큐에 있을 수 있다
2. 각 프로세서는 자신만의 스레드 큐를 가질 수 있다

**다중 코어 프로세서**

프로세서가 메모리보다 훨씬 빠르게 작동하면서, 프로세서는 메모리가 가용해질 때까지 기다리는 메모리 스톨 현상 발견

→ 칩 다중 스레딩(CMT): 칩 하나의 코어에 2개 이상의 하드웨어 스레드를 할당하여 메모리를 기다리는 동안 다른 스레드로 전환

fine-grained 다중 스레딩은 명령어 주기의 경계에서 좀 더 정밀한 시점에 스레드 교환이 일어나지만 스레드 교환을 위한 회로를 포함해서 교환 비용이 적다.

처리기 선호도

캐시 무효화 후 다시 채우는 비용이 많이 들기 때문에 하나의 프로세서에서 돌던 스레드는 계속 그 프로세서에서 돌리려고 한다.
