# 운영체제 스터디 8주차 정리

6.7 모니터부터

- 세마포를 잘못 사용하면 발견하기 어려운 타이밍 오류를 야기할 수 있음.
- 특정 실행 순서로 진행되었을 때만 발생하고 이런 순서가 항상 일어나는 것은 아니기 때문

mutex

- 각 프로세스가 임계구역에 진입하기 전에 wait(mutex)를 실행해야 하고, 나올 때 signal(mutex)를 실행해야 함.

case 1. wait()과 signal() 연산의 순서가 바뀐 상황

- 여러 프로세스가 동시에 임계구역 안에서 실행될 수 있어 상호 배제 조건을 위반하게 됨.

```c
signal(mutex);
	...
	// critical section
	...
wait(mutex);
```

case2. signal(mutex)를 써야 할 곳에 잘못해서 wait(mutex)를 쓰는 경우

- 세마포를 사용할 수 없으므로 두번 째 wait() 호출에서 여구적으로 봉쇄됨.

```c
wait(mutex);
	...
	// critical section
	...
wait(mutex);
```

case3. wait()나 signal() 또는 둘 다를 빠트렸을 경우

- 상호 배제 요구 조건을 위반하든지 프로세스가 영원히 봉쇄됨.

## 모니터 (monitors)

\: 간단한 동기화 도구를 통합해 고급 언어 구조물을 제공하는 것

### ADT (Abstract Data Type)

\: 데이터와 테이터를 조작하는 함수들의 집합을 하나의 단위로 묶어 보호

- 다른 프로세스들이 직접 사용할 수 없으며, 오직 모니터 내에 지역적으로 선언된 변수들과 형식 매개변수들에만 접근할 수 있음.

동기화 기법 → condition이라는 구조물(struct?)로 정의할 수있음.

- condition 형 변수에 호출될 수 있는연산은 오직 wait(), signal() 만 있다.
- x.signal() 연산은 정확히 하나의 일시 중지 프로세스를 재개하고, 일시 중지된 프로세스가 없으면 아무런 동작을 하지 않음.

### 세마포를 이용한 모니터 구현

- 프로세스는 모니터로 들어가기 전에 wait(mutex)를 실행하고 모니터를 나온 후에 signal(mutex)를 실행해야 함. → signal-and-wait 기법을 사용
- 모니터가 제공해야 하는 것
    - 상호배제 → 모니터 안의 메서드는 한 번에 하나의 스레드만 실행되게 함.
    - 조건 동기화 → wait()/signal() 같은 조건변수 연산으로 특정 조건이 만족될 때까지 잠들기/깨우기

- 모니터 진입/탈출
    - enterMonitor()

        ```c
        mutex.wait()
        ```

    - exitMonitor()

        ```c
        if (nextCount > 0) next.signal()
        else              mutex.signal()
        ```


- 조건변수 연산
    - c.wait() - 조건이 만족될 때까지 잠들기

        ```c
        c.count++
        
        if (nextCount > 0) next.signal()
        else               mutex.signal()
            // 모니터 락을 내놓고 다른 스레드가 들어올 수 있게 함
        
        c.sem.wait()   // 여기서 잠듦 (누군가 c.signal() 해줄 때까지)
        
        c.count--
        ```

    - c.signal() - 기다리는 스레드 하나 깨우기

        ```c
        if (c.count > 0) {
          nextCount++
          c.sem.signal()  // c.wait() 중인 스레드 하나 깨움
          next.wait()     // 나는 잠깐 멈춤 → 깨어난 스레드가 모니터를 즉시 실행(바통)
          nextCount--
        }
        ```


### 모니터 안에서 재개되는 순서

1. FCFS: 가장 오래 기다린 순서
2. conditional-wait: 우선순위 번호를 이용

### 라이브니스

\: 프로세스가 실행 수명주기 동안 진행되는 것을 보장하기 위해 시스템이 충족해야 하는 일련의 속성

- 교착 상태
    - 두 개 이상의 프로세스들이 오로지 대기 중인 프로세스들 중 하나에 의해서만 야기될 수 있는 이벤트를 무한정 기다리는 상황
- 우선순위 역전
    - 높은 우선순위 프로세스가 현재 낮은 우선순위의 프로세스에 의해 접근되고 있는 커널 데이터를 읽거나 변경할 필요가 있을 때 생기는 문제 → 우선순위 상속 프로토콜을 구현해 해결 가능
- 우선순위 상속 프로토콜
    - 더 높은 우선순위 프로세스가 필요로 하는 자원에 접근하는 모든 프로세스는 문제가 된 자원의 사용이 끝날 때까지 더 높은 우선순위를 상속받음.