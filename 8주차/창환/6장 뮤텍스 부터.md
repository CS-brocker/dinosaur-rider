## Mutex Lock
실제로 이제 상호배제를 제공하는 도구를 다룬다.  

-> 이게 우리가 생각하는 상호배제를 위한 해결책이다 여태까지 본거는 다 그냥 이걸 하기위한 도구들이였다.

기존 제시된 내용들 원자적 변수, 하드웨어 명령어, 메모리 장벽 이런것들을 이용해서 상호배제를 직접 구현하려면  
너무 품이 많이들고 그야말로 저수준의 내용까지 알아야하니 이걸 운영체제(혹은 언어/런타임 차원)에서 상호배제를 위해 추상화를 시켜주고 그거 쓰게 던져준거다.  

기본 적인 개념은 1개짜리 Lock 을 제공하는것이다.
이를 위해 두가지 연산과 한가지 상태를 가지는데 다음과 같다.
- acquire / Lock 획득연산
- release / Lock 풀어주는 연산
- available / 현재 Lock의 가용여부(상태) -> Private

그래서 이런식으로 구성된다.
```
acquire(){
    while(!available)
        ;/* busy wait */
    available = false;
}
```

```
release(){
    available = true;
}
```

근데 지금 구현방식을 보면 busy wait)을 시킨다.  
-> 책에서 busy wait은 cpu를 그냥 소모시켜 성능을 떨어트릴수 있다고 한다.  

하지만 대기상태로 놓고 다른일을 할때는 context스위칭이 2번 일어나는데 이 비용이 더 클수 있기 때문에  
이 비용과 cpu가 날아가는 비용을 비교했을때 context스위칭 비용이 크다면 그냥 이방법을 택하는게 나을수도 있다고 한다.  
그래서 스핀락이라고도 부르고 다중코어 시스템에서 스핀락을 잘사용하고 있고 널리사용된다고 한다.


사견: 일반적으로 여태까지 학습할때 busy wait은 성능을 겁나 떨어트린다고 생각했는데 운영체제 구현이나 코루틴 구현 그리고 지금과  같은 상황을 봤을때 상황에 따라 사용을 고려해볼수 있는 방법인것 같다.(어태까지 극강의 안티패턴이라 인식)


## 세마포(Semaphores)
### 개념
세마포 잡설 부터 시작한다.  
세마포는 다익스트라가 고안했다고한다 그 다익스트라 알고리즘의 다익스트라다.  

역시 천재라 한가지 족적만 남긴게 아니다.
다익스트라가 네덜란드인이라 그 연산이 P,V 이렇게 표시하는데(강의 보면 그냥 갑자기 P,V갈김) 네덜란드말 앞글자란다.

세마포어 기본적인 개념은 정수개의 Lock을 제공하는것이고
이를 위해 정수값 상태와 2가지 연산을 제공한다.
- wait(P) / Lock 획득 시도
- signal(V) / Lock 놓기
- S / 정수값(lock 갯수 표현)

세마포어 정수값 연산은 원자적으로 수행되어야하고 상호배제도 일어나야하며 wait 연산또한 인터럽트로 중간에 찢어지면 안된다고 하는데
그건 뭐 jvm 에서 제공하는 추상체가 알아서 하겠지 내가 그것까지 골머리 썩을건 아니라고 생각한다.  
물론 알면 좋지만 그렇게 따지면 어셈블리로 코딩하는 벙법부터 공부해야지 괜히 c언어가 나왔겠는가?

### 사용법
이진과 카운팅이 있다는데 이진은 사실상 뮤텍스랑 거의 동치라 보면된다.  
그래서 몇몇 시스템에서는 뮤텍스를 아예 제공하지 않고 이진 세마포어를 쓰는경우가 있다고 한다.  

그냥 우리가 생각하는대로 가용가능 자원갯수로 정수 초기화 자원을 얻고 반환하고 그런식으로 사용을 이야기한다.

사실 요즘 언어에서 이런식으로 안쓰겠지만 세마포어로 명령어 실행순서를 보장하는 방법도 간단하게 나온다.
그냥 예시는 직접 책에서 보자(중요하지 않은것 같다.)

### 구현
세마포어구현을 설명한다기 보다는 스핀락과 프로세스를 아예 재웠다가(대기상태) 꺠우는 구현을 설명한다.

프로세스 재우는거는 우리가 일반적으로 스레드 sleep 걸어서 대기큐에 넣고 꺠우고 하는거랑 같다.  
그래서 그 연산은 운영체제에서 시스템콜로 sleep,wakeup 연산으로 제공된다.

세마포어 구현체는 정수랑 대기 프로세스 리스트를 가지는데  
대기하는 프로세스 리스트의 경우 PCB 자체의 포인터를 들고있는다고 한다.  
그리고 리스트의 큐잉전략은 뭘써도 상관없다고 한다(선입선출을 예시로듬)  

여기서 부터 구현에 대해 핵심적으로 말하고싶어보이는 내용이 나온다.  
세마포어는 원자적으로 실행되어야하고 두 프로세스가 동시에 연산들을 실행할수 없도록 임계구역 문제를 해결해야하는데  
단일 처리기는 연산의 인터럽트만 금지하면되는데  
다중 코어에서는 인터럽트를 금지하는게 어려울수 있고 성능이 떨어져서 그냥 스핀락을 오히려 사용한다고 한다.(뭐 상황 맞춰서)  
스핀락을 wait/signal 에만 국한해서 사용하고 이거는 대기가 짧아서 상관없다고 한다. 
근데 대기시간이 길면 극도로 비효율 적이 된다고 한다.  

## 모니터
이유 세마포,뮤텍스 줬는데 준대로 안쓰고 휴먼에러를 막 발생시키는 개찐빠들을 위하여 그런것들을 휴먼에러 안나게 추상화해서 제공하는게 모니터다.  
그리고 개찐빠를 욕하지마라 그 개찐빠가 나다.

#### 모니터 사용법
책에서 뭘 말하고싶은건지 아예 이해가 가지않는다. 내가 개찐빠인건지 아님 글을 진짜 못쓰는건지 모르겠는데 걍 모니터는 객체다 이생각밖에 안든다.(실제로 java ,c#에서 모니터 개념을 편입시켰다는거 보면 객체가 맞다)

#### 세마포를 이용한 모니터의 구현
