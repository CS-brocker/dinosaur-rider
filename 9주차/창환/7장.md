# 7장 동기화 예제

예제를 다루는 장이다 6장에서 학습한 내용에 대한것들을 고전적으로 발생하는 문제들에 어떻게 적용해서 풀지,  
각 운영체제나 런타임에서는 어떻게 사용하는지 살펴본다.

## 고전적인 동기화 문제
그냥 학습용이자 새로운 동기화 해결방법이 나왔을때 잘 짜여졌는지 검증할수있는 수문장 역할이다.  
학습을 위해 다시 둘러보자

### 유한 버퍼문제
기록할 만한게 없다 그냥 뭔가 문제가 생겼다면 와서 책다시 읽자  

### Readers-Writers 문제
여러곳에서 동시에 읽는건 문제 발생 안함  
쓰기와 쓰기, 쓰기와 읽기가 동시에 일어나면 문제 발생  
그래서 쓸때 자원획득을 해서 쓰도록 조치하는 문제이다.  

책에서 이런것들을 고려할때 문제점이 발생한다는데 말을 뒤지게 못한다.

첫번째 문제
요약: “읽는 애들이 많을 때, 쓰는 애는 언제 들어갈 수 있나?”
- 👉 Reader를 최대한 우대
  - Reader는 서로 절대 막지 않음
  - Writer는 Reader가 모두 끝난 뒤에만 접근 가능
- 특징
  - 여러 Reader 동시 접근 허용
  - Writer는 Reader가 하나라도 있으면 대기
  - 새로운 Reader가 계속 들어오면? Writer 기아현상 발생 가능성있음

두번째 문제
요약: “Writer가 기다리고 있으면, Reader를 계속 들여보내도 되나?”
- 👉 Writer를 우대
  - Writer가 대기 중이면
  - 새로운 Reader 진입 금지
- 특징
  - Writer가 기다리기 시작한 순간 이후 Reader는 전부 block
  - 기존 Reader만 끝나면 Writer 바로 실행
  - 이번엔 reader 기아현상 발생가능(writer 계속 들어옴)

그리고 책에서 문제가 있다고 해놓고 해결법을 말안하고 뭔 부록에 있다고하고 다음에 본다고하고  
뭔말이 하고싶은지 모르겠으나 일단 gpt와 이문제 어떻게 해결하는 변형이 있는지 살펴봤다.

걍 들어온 순서대로 처리하는 FIFO 큐로 처리한단다.
>“Reader / Writer 요청을 하나의 큐에 넣고, 들어온 순서(FIFO)를 기준으로 접근 권한을 부여한다.”
근데 gpt한테 답변듣기전에도 아니 순서대로 처리하면되자나 비효울적인가? 이 생각을 계속하고 있었는데 역시 사람생각은 똑같다.

뭐 다른 변형으로 문제점들을 해결하는 방법이 많겠지만 일반적으로 FIFO 큐로 해결한다고 한다.

### 식사하는 철학자
자 맨날 나오는거 나왔다 그냥 맘같아서는 수저도 못집는 놈들은 도태되는게 당연한거 아닌가?  
자연의 알고리즘을 무시하는 행위라는 생각이 스멀스멀 올라오지만(이래서 격투기를 배워야함 수저를 뻇겠다는 마인드) 일단 살펴보면  

책의 예시는 세마포랑 모니터로 데드락이 안일어나지만 스타빙은 일어날 수 있는 해결책을 보여준다.  
근데 솔직히 모니터 예제는 c로 보면 머리통이 터져서 gpt한테 각예시 코틀린으로 들어달라했다.  
뭐 쩃든 이걸보고 이해하는게 나은거같다.

<details>
<summary>코틀린 모니터 예제 구현</summary>

```kotlin
import kotlin.random.Random

private enum class State { THINKING, HUNGRY, EATING }

/**
 * Dining Philosophers Monitor
 *
 * - 단 하나의 모니터(이 객체의 intrinsic lock)로 모든 상태를 관리합니다.
 * - pickup(): HUNGRY로 바꾸고, 양 옆이 EATING이 아니면 EATING으로 전환.
 *            아니면 wait()로 잠들었다가 누군가 putdown()에서 notifyAll() 하면 다시 검사.
 * - putdown(): THINKING으로 바꾸고 notifyAll()로 모두 깨워 재검사 유도.
 *
 * 이 구조는 "젓가락을 하나씩 들다가 교착" 같은 deadlock을 원천 차단합니다.
 */
class DiningPhilosophersMonitor(
    private val n: Int
) {
    private val state = Array(n) { State.THINKING }

    private fun left(i: Int) = (i + n - 1) % n
    private fun right(i: Int) = (i + 1) % n

    /** i가 지금 먹어도 되는지(양 옆이 먹는 중이 아닌지) 검사 */
    private fun canEat(i: Int): Boolean {
        return state[i] == State.HUNGRY &&
                state[left(i)] != State.EATING &&
                state[right(i)] != State.EATING
    }

    /**
     * 젓가락 집기(= 먹기 시작 요청)
     * - 모니터 진입 후 상태를 HUNGRY로 만들고
     * - 먹을 수 있을 때까지 while 루프로 조건을 재검사하며 wait()
     */
    fun pickup(i: Int) {
        synchronized(this) {
            state[i] = State.HUNGRY

            // spurious wakeup 방지: 반드시 while 로 조건 재검사
            while (!canEat(i)) {
                // 누군가 putdown()에서 notifyAll() 해주면 깨어나서 다시 검사
                wait()
            }

            state[i] = State.EATING
        }
    }

    /**
     * 젓가락 내려놓기(= 먹기 종료)
     * - 상태를 THINKING으로 바꾸고
     * - 주변 철학자들이 먹을 수 있을지 다시 검사하도록 notifyAll()
     */
    fun putdown(i: Int) {
        synchronized(this) {
            state[i] = State.THINKING
            notifyAll()
        }
    }
}

/** 철학자 스레드 */
class Philosopher(
    private val id: Int,
    private val monitor: DiningPhilosophersMonitor,
    private val random: Random = Random(id)
) : Thread("Philosopher-$id") {

    override fun run() {
        repeat(30) { round ->
            think(round)
            monitor.pickup(id)
            try {
                eat(round)
            } finally {
                monitor.putdown(id)
            }
        }
    }

    private fun think(round: Int) {
        // 생각(랜덤 sleep)
        Thread.sleep(random.nextLong(10L, 80L))
    }

    private fun eat(round: Int) {
        // 먹기(랜덤 sleep)
        Thread.sleep(random.nextLong(10L, 60L))
    }
}

fun main() {
    val n = 5
    val monitor = DiningPhilosophersMonitor(n)

    val philosophers = (0 until n).map { Philosopher(it, monitor) }
    philosophers.forEach { it.start() }

    // 간단 모니터링(상태 출력)
    repeat(40) {
        Thread.sleep(100)
        println("state = ${monitor.snapshot()}")
    }

    philosophers.forEach { it.join() }
    println("done")
}
```

이 방식이 “모니터로 해결”인 이유와 동작 포인트
- 공유 자원(젓가락)을 개별 락으로 쪼개지 않고, “먹을 수 있는지”를 상태 머신으로 표현합니다.
- pickup()은
  1. HUNGRY로 표시
  2. while (!canEat(i)) wait() 로 조건이 만족될 때까지 잠듦
  3. 조건 만족 시 EATING으로 전환
- putdown()은
  1. THINKING으로 복귀
  2. notifyAll()로 잠든 스레드들을 깨워 “이제 먹을 수 있는 사람 있나?”를 재검사하게 함
- while을 쓰는 이유: JVM의 wait()는 spurious wakeup(이유 없이 깨어남)이 가능하므로, 깨어나면 조건을 다시 검사해야 안전합니다.

</details>

## 커널 안에서의 동기화
### windows의 예시
솔직히 그냥 읽고 넘어가는거지 그닥 공감가지 않는다.  
내부적으로 스핀락을 짧은 락을 컨트롤하는데 사용하고 스린락을 도는동안 선점되지 않게 관리한다고 한다.  

또한 Dispatcherr객체를 제공하는데  
Mutex, Semaphore, Event, Timer 이런것들을 커널에서 객체로 제공한단다.
그래서 뭐 각 대기큐가 있고 뭐 객체로 어쩌구 저쩌구 관리한다는데 내용이 애매해서 딱히의미 없다.

### Linux의 예시
솔직히 별로 필요없다.  
OS의 대략적인 구현이야기 원자적변수 사용하고 락기법들 다 앞쪽에서 이야기한것들인데 그원리를 이해만하면되지 딱히 리눅스에서 뭘썼는지는 내가 알고싶은 영역 밖인것 같다.

### POSIX의 예시
이거는 그나마 커널이야기가 아니라 우리같은 응용프로그래머가 사용하는 락 관련 api이야기인데 이또한 딱히 의미없었다.  
나는 POSIX 환경에서 개발하고 있지 않고 책에서 그냥 단순히 api를 나열하고있어서 그냥 흐음 하고 봤다.  
기명 세마포, 무기명 세마포가 있긴한데 뭐 이것도 다들 어떤개념인지 한방에 와닿을거다.(프래그먼트에 태그붙여서 찾는느낌)

### Java의 예시 
이제 나의 언어 자바가 나온다 히히히히히히히 이제 열심히 봐야지  
