# 7장 동기화 예제

예제를 다루는 장이다 6장에서 학습한 내용에 대한것들을 고전적으로 발생하는 문제들에 어떻게 적용해서 풀지,  
각 운영체제나 런타임에서는 어떻게 사용하는지 살펴본다.

## 고전적인 동기화 문제
그냥 학습용이자 새로운 동기화 해결방법이 나왔을때 잘 짜여졌는지 검증할수있는 수문장 역할이다.  
학습을 위해 다시 둘러보자

### 유한 버퍼문제
기록할 만한게 없다 그냥 뭔가 문제가 생겼다면 와서 책다시 읽자  

### Readers-Writers 문제
여러곳에서 동시에 읽는건 문제 발생 안함  
쓰기와 쓰기, 쓰기와 읽기가 동시에 일어나면 문제 발생  
그래서 쓸때 자원획득을 해서 쓰도록 조치하는 문제이다.  

책에서 이런것들을 고려할때 문제점이 발생한다는데 말을 뒤지게 못한다.

첫번째 문제
요약: “읽는 애들이 많을 때, 쓰는 애는 언제 들어갈 수 있나?”
- 👉 Reader를 최대한 우대
  - Reader는 서로 절대 막지 않음
  - Writer는 Reader가 모두 끝난 뒤에만 접근 가능
- 특징
  - 여러 Reader 동시 접근 허용
  - Writer는 Reader가 하나라도 있으면 대기
  - 새로운 Reader가 계속 들어오면? Writer 기아현상 발생 가능성있음

두번째 문제
요약: “Writer가 기다리고 있으면, Reader를 계속 들여보내도 되나?”
- 👉 Writer를 우대
  - Writer가 대기 중이면
  - 새로운 Reader 진입 금지
- 특징
  - Writer가 기다리기 시작한 순간 이후 Reader는 전부 block
  - 기존 Reader만 끝나면 Writer 바로 실행
  - 이번엔 reader 기아현상 발생가능(writer 계속 들어옴)

그리고 책에서 문제가 있다고 해놓고 해결법을 말안하고 뭔 부록에 있다고하고 다음에 본다고하고  
뭔말이 하고싶은지 모르겠으나 일단 gpt와 이문제 어떻게 해결하는 변형이 있는지 살펴봤다.

걍 들어온 순서대로 처리하는 FIFO 큐로 처리한단다.
>“Reader / Writer 요청을 하나의 큐에 넣고, 들어온 순서(FIFO)를 기준으로 접근 권한을 부여한다.”
근데 gpt한테 답변듣기전에도 아니 순서대로 처리하면되자나 비효울적인가? 이 생각을 계속하고 있었는데 역시 사람생각은 똑같다.

뭐 다른 변형으로 문제점들을 해결하는 방법이 많겠지만 일반적으로 FIFO 큐로 해결한다고 한다.

### 식사하는 철학자
자 맨날 나오는거 나왔다 그냥 맘같아서는 수저도 못집는 놈들은 도태되는게 당연한거 아닌가?  
자연의 알고리즘을 무시하는 행위라는 생각이 스멀스멀 올라오지만(이래서 격투기를 배워야함 수저를 뻇겠다는 마인드) 일단 살펴보면  

