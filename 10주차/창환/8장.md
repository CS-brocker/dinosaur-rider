# 8장 DeadLock
서론: 멀티프로그래밍에서 일어나는 Deadlock 이야기를 하며 이번장에서는 하기 항목들을 살펴본다고 한다.
- Mutex Lock 사용시 일어나는 데드락 상황
- 데드락 되는 4가지 조건
- 자원할당 그래프에서 데드락 상황식별
- 데드락 피하는 4가지 방법
- 데드락 회피를 위한 은행의 알고리즘 적용
- 데드락 감지 알고리즘 적용
- 데드락에서 복구방법 

## 시스템 모델
-> 내용이 없다 두루뭉술하게 데드락을 설명하는데 이정도 개념은 우리 킥복싱 코치님도 안다.(이런걸 왜이렇게 장황하게)  
그냥 각 자원별 인스턴스가 여러개 존재하고 배분한다. 그 와중에 데드락 발생할 수 있으니 조심해라 이 정도다.
차라리 구체적인 예시를 바로주면 좋을것 같다.

---

## 다중 스레드 응용에서 교착상태
Pthread로 데드락 예시 보여주는데 그 알고있는 뻔한거다.  
그래서 그냥 어짜피 나중에 이거 다시볼테니 코틀린으로 짜라고 gpt한테 시켰다.  

<details>
<summary>코틀린 예시</summary>

```kotlin
import kotlinx.coroutines.sync.Mutex

private val lockA = Mutex()
private val lockB = Mutex()

/**
 * - A -> B 순서로 락을 잡고
 * - 임계구역 수행 후
 * - 역순으로 해제
 */
suspend fun updateUserAndCache() {
    // 1) 첫 번째 락 획득 직후부터 무조건 finally로 해제 보장
    lockA.lock()
    try {
        // 2) 두 번째 락도 동일하게 "획득 직후" finally로 해제 보장
        lockB.lock()
        try {
            // === 임계구역 시작 ===
            // 예: 유저 데이터 갱신 + 캐시 갱신을 "함께" 보호해야 함
            // - userTable.update(...)
            // - memoryCache.put(...)
            // === 임계구역 끝 ===
        } finally {
            lockB.unlock()
        }
    } finally {
        lockA.unlock()
    }
}

/**
 * - B -> A 순서로 락을 잡는 다른 작업
 *
 * ⚠️ 이 함수가 위 함수와 동시에 돌면 데드락 가능:
 *    - 한쪽은 A 잡고 B 기다림
 *    - 다른 쪽은 B 잡고 A 기다림
 */
suspend fun refreshCacheAndUser() {
    lockB.lock()
    try {
        lockA.lock()
        try {
            // === 임계구역 시작 ===
            // 예: 캐시 정리 + 유저 상태 갱신을 "함께" 보호해야 함
            // - memoryCache.evict(...)
            // - userState.update(...)
            // === 임계구역 끝 ===
        } finally {
            lockA.unlock()
        }
    } finally {
        lockB.unlock()
    }
}
```

참고: 실제로 짠다면 withLock을 이용해서 코드를 좀더 깔끔하게 만들거임
```kotlin
suspend fun updateUserAndCache() {
    lockA.withLock {
        lockB.withLock {
            // === 임계구역 ===
        }
    }
}
```

</details>
</br>

결국 이 부분에서 하고싶었던 말은 그냥 단독으로 돌아가면 잘 돌아가도 타이밍이 잘못걸리면 데드락이 걸릴수 있는 상황이 있을수 있으니 주의가 필요하다는 말 같다.

### 라이브 락
이것도 데드락이랑 사실상 마찬가지다.  
예시보는게 더 빠르다.

<details>
<summary>코틀린 예시</summary>

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex

private val lockA = Mutex()
private val lockB = Mutex()

fun main() = runBlocking {
    launch(Dispatchers.Default) { worker1() }
    launch(Dispatchers.Default) { worker2() }
}

/**
 * worker1: A -> B 순서
 * 두 번째 락 실패 시 첫 번째 락을 풀고 재시도
 */
private suspend fun worker1() {
    while (true) {
        if (!lockA.tryLock()) continue

        try {
            println("W1: A 획득")

            if (lockB.tryLock()) {
                try {
                    println("W1: B까지 획득 -> 작업 성공")
                    // === 임계구역 ===
                    return
                } finally {
                    lockB.unlock()
                }
            } else {
                println("W1: B 실패 -> A 풀고 양보")
            }
        } finally {
            lockA.unlock()
        }
    }
}

/**
 * worker2: B -> A 순서 (worker1과 반대)
 */
private suspend fun worker2() {
    while (true) {
        if (!lockB.tryLock()) continue

        try {
            println("W2: B 획득")

            if (lockA.tryLock()) {
                try {
                    println("W2: A까지 획득 -> 작업 성공")
                    // === 임계구역 ===
                    return
                } finally {
                    lockA.unlock()
                }
            } else {
                println("W2: A 실패 -> B 풀고 양보")
            }
        } finally {
            lockB.unlock()
        }
    }
}

// 박수치듯이 둘이 박자가 맞아야 라이브락에 걸린다.
// -> delay를 랜덤으로 넣어주면 풀림

while(true) {
  if (tryLock 실패) delay((1L..10L).random())
}
```



</details>
</br>

그냥 일상생활에서의 예시는 길가다가 서로 부딪쳤을떄 서로 양보하다가 또 마주서고 이런 예시를 든다.  

해결책: 랜덤한 딜레이를 trylock 실패지점에 끼워넣으면 해결된다.

---


## 교착 상태 특성
이게 교착상태인지 판단하는 조건을 살펴본다.

### 필요조건들
일단 한 시스템 내 하기 4가지 조건이 동시에 있어야 발생한다.

1. 상호 배제 
   - 당연한 소리지만 최소 하나의 자원이 비공유 모드로 점유 되어야한다(스레드가 자원 못얻으면 지연 되어야함)
2. 점유하며 대기
   - 스레드는 최소한 하나의 자원 점유하고 못얻은 다른 자원(다른 스레드가 쥔)을 얻기위해 대기해야한다.
3. 비선점
   - 자원 선점이 불가능해야한다. -> 다 뻇어가면 그냥 돌고 풀릴테니까
4. 순환대기 
   - 스레드가 작업을 완성하려면 서로서로 다른 스레드가 가진걸 원해야한다.

#### 🐗여기서 드는 의문(책에는 안나옴)
[ 1차 질문 내용 ]
자바 synchronized 의 wait/notify 나 재진입 락의 condition(await/signal) 이거는 락을 놓고 대기하는데
그럼 애초에 필요조건 자체가 안일어나지 않나? 이것들을 사용하면?
그럼 라이브락 정도는 걸릴수 있을것 같은데 그럼 랜덤 딜레이만 주면 자바/코틀린에서는 이런거 걱정을 안해도 되는거 아닌가?(조건자체가 성립을 안하는데)

<details>
<summary>🤖답변</summary>

핵심부터 말하면: **wait/notify, await/signal을 쓴다고 데드락이 자동으로 방지되는 것은 아니다.**

**wait/notify가 락을 놓는 건 맞지만, 그건 "하나의 락" 에 대해서만 성립한다.**

데드락이 진짜 문제가 되는 건 **여러 개의 락을 동시에 얻으려 할 때**이다.

```java
// 스레드 A
synchronized (lockA) {       // lockA 획득
    synchronized (lockB) {   // lockB 대기 → 여기서 lockA를 놓지 않음!
    }
}

// 스레드 B
synchronized (lockB) {       // lockB 획득
    synchronized (lockA) {   // lockA 대기 → 여기서 lockB를 놓지 않음!
    }
}
```

이 상황에서 `synchronized` 블록 진입 시 모니터 락을 놓지 않고 대기한다. `wait()`를 호출해야 락을 놓는 것이지, **`synchronized` 진입 대기 자체는 락을 놓지 않는다.**

즉:
- `wait/notify` → **하나의 모니터 안에서** 조건이 안 맞을 때 락을 놓고 대기. "점유하며 대기" 조건을 깨는 게 맞음.
- 하지만 **여러 락을 중첩 획득하는 구조**에서는 `wait/notify`와 무관하게 `synchronized` 진입 대기 자체가 락을 안 놓으므로 **"점유하며 대기" 조건이 그대로 성립**한다.

결론:
- **단일 락 + wait/notify 패턴** → 데드락 가능성 낮음 (점유하며 대기 조건이 깨짐)
- **다중 락 중첩 획득** → wait/notify와 무관하게 데드락 가능 (4가지 조건 모두 성립 가능)
- 라이브락은 별개의 문제이고, 랜덤 딜레이로 완화 가능한 건 맞음

자바/코틀린이라고 데드락에서 자유로운 게 아니라, **락 획득 순서를 일관되게 유지하는 것(순환 대기 조건 파괴)** 이 가장 확실한 방법이다.

---
[ 2차 질문 내용 ]
근데 synchronized가 try lock이 없어서 그렇지 재진입 락을 사용해서 두 번째 락을 tryLock으로 얻고 continue로 재우고 깨우고 이런 거 하면 문제없는 구조가 나오지 않아?  
재진입락 기능들 보면 재진입락 사용 자체만으로도 저 데드락 4가지 조건을 회피할 수 있을 것 같아서.

[ 🤖답변 ]
**맞다. 정확한 포인트를 짚었다.** `ReentrantLock`의 `tryLock()`을 쓰면 데드락 필요조건 중 **"비선점"** 과 **"점유하며 대기"** 를 깰 수 있다.

```java
ReentrantLock lockA = new ReentrantLock();
ReentrantLock lockB = new ReentrantLock();

// 스레드 A
while (true) {
    lockA.lock();
    try {
        if (lockB.tryLock()) {  // 두 번째 락을 비블로킹으로 시도
            try {
                // 둘 다 획득 성공 → 작업 수행
                break;
            } finally {
                lockB.unlock();
            }
        }
    } finally {
        lockA.unlock();  // 못 얻으면 첫 번째 락도 놓음 → "점유하며 대기" 파괴!
    }
    // 잠깐 쉬고 재시도 (라이브락 방지용 랜덤 딜레이)
    Thread.sleep(random.nextInt(10));
}
```

이 구조가 데드락 4조건을 어떻게 깨는지 정리하면:

| 필요조건 | `synchronized` | `ReentrantLock` + `tryLock()` |
|---------|---------------|-------------------------------|
| 상호 배제 | 그대로 | 그대로 (락 자체는 배타적) |
| 점유하며 대기 | **성립** (못 얻어도 기존 락 안 놓음) | **파괴** (tryLock 실패 시 기존 락도 놓고 재시도) |
| 비선점 | **성립** (강제 해제 불가) | **파괴** (tryLock이 실패하면 스스로 포기 = 사실상 선점 효과) |
| 순환 대기 | 순서 안 지키면 성립 | tryLock 패턴 자체가 순환 고리를 끊어버림 |

그래서 **결론적으로 맞는 말이다.** `ReentrantLock`의 `tryLock()`을 활용하면 `synchronized`에서는 불가능했던 **"못 얻으면 내가 가진 것도 놓기"** 패턴이 가능해지고, 이것만으로 데드락 필요조건 자체가 성립하지 않게 된다.

다만 주의할 점:
- **라이브락 가능성**은 있다 → 두 스레드가 계속 동시에 tryLock 실패하고 놓고를 반복. 이건 앞서 말한 대로 **랜덤 딜레이**로 해결.
- `tryLock(timeout, unit)` 을 쓰면 타임아웃까지 줄 수 있어서 더 안정적.
- `lockInterruptibly()`도 있어서 대기 중 인터럽트로 빠져나오는 것도 가능.

즉, **`synchronized`의 한계 = tryLock이 없다**는 것이고, `ReentrantLock`은 그 한계를 정확히 메워준다. 그래서 실무에서 다중 락이 필요한 상황에서는 `ReentrantLock`을 쓰는 게 맞다.

---
[ 3차 질문 내용 ]
tryLock으로 깨지는 건 "점유하며 대기"인데 "비선점"도 깨진다고 한 건 틀리지 않아?  
선점은 남이 뺏는 건데 내가 놓는 건 선점이 아니잖아.  

그리고 원래 궁금했던 건 Condition으로 lock을 놓고 잘 수 있는 건데, Condition으로 "점유하며 대기"를 깰 수는 없나?

[ 🤖답변 ]
**1. "비선점 파괴" → 지적이 맞다. 정정한다.**

"비선점(No Preemption)"은 **다른 주체가 강제로 자원을 빼앗는 것**이다. tryLock 실패 시 내가 자발적으로 놓는 건 선점이 아니라 **"자발적 포기"** 다. tryLock 패턴이 깨는 건 정확히 **"점유하며 대기"** 하나다. 2차 답변의 표에서 "비선점 → 파괴"라고 쓴 건 부정확했다.

**2. Condition으로 "점유하며 대기"를 깰 수 있는가? → 이 시나리오에서는 안 된다.**

이 문서에서 다루는 데드락은 **lockA, lockB라는 각기 다른 자원**을 서로 다른 순서로 얻으려다 걸리는 상황이다.

```
스레드 A: lockA 획득 → lockB 필요 (대기)
스레드 B: lockB 획득 → lockA 필요 (대기)
```

Condition의 `await()`는 **자기가 속한 락 하나만** 놓는다. lockA에서 만든 Condition을 `await()` 하면 lockA만 놓지, lockB는 건드리지 않는다. 그러니까:

- lockA를 쥐고 lockB를 못 얻어서 → lockA의 Condition으로 `await()` → lockA를 놓음
- 그런데 lockA를 놓으면 **자원 A 자체를 포기한 거**다. 다시 lockA부터 얻어야 한다.
- 이건 결국 **tryLock + 놓고 재시도**와 동일한 동작이지, Condition의 "조건이 맞으면 깨워줌" 메커니즘을 활용한 게 아니다.

**Condition이 진짜 빛나는 곳**: 하나의 락 안에서 **"특정 조건이 충족될 때까지 대기"** 하는 패턴이다. (예: 생산자-소비자에서 "버퍼가 빌 때까지 대기", "버퍼가 찰 때까지 대기")

**결론**: 각기 다른 자원(lockA, lockB)을 두고 경쟁하는 데드락 시나리오에서는 **tryLock + 놓고 재시도**(2차 답변)가 맞는 해법이다. Condition은 이 문제의 도구가 아니다.

---
[ 4차 질문 내용 ]
그럼 너가 3차 답변에서 한 이야기는 사실상 lock가 분리되어있는 상황인데
만약 Lock을 하나로 바꾸고 그 안에 자원당 condition을 놓도록 리펙터링 한다면 사실상 condition으로 이 데드락 조건을 깰 수있는거아냐?
근데 리펙터링이 필요하니 실질적으로 실무에서 사용하기는 힘들수 있겠지만(이미 락이 두개로 분리된상황에 락에 많은 로직이 의존해있는 경우)

그리고 락을 하나로 합치면 자원이 꼭 같이 움직여야하는게 아니라 각각 쓰이는경우가 더 많다면 성능도 떨어지겠지? 아무래도 그 두개가 합쳐지는거나 다름없으니까 하나로 통일해서 관리하는거나 다름없으니까

[ 🤖답변 ]
**1. 락 하나 + 자원당 Condition → 데드락 조건 파괴 맞다.**

락을 하나(`masterLock`)로 합치고 자원마다 Condition을 두면:

```java
ReentrantLock masterLock = new ReentrantLock();
Condition condA = masterLock.newCondition(); // 자원 A용
Condition condB = masterLock.newCondition(); // 자원 B용
```

이 구조에서 자원 A가 없으면 `condA.await()` → masterLock 전체를 놓고 잠든다.
자원 B가 없으면 `condB.await()` → 마찬가지로 masterLock을 놓고 잠든다.

데드락 4조건이 어떻게 되는지 보면:

| 필요조건 | 결과 | 이유 |
|---------|------|------|
| 상호 배제 | 그대로 | 자원 자체는 여전히 배타적 |
| 점유하며 대기 | **파괴** | await() 하면 masterLock을 통째로 놓음 |
| 비선점 | 그대로 | 강제로 뺏는 건 여전히 없음 |
| 순환 대기 | **파괴** | 락이 하나뿐이라 순환 구조 자체가 성립 안 함 |

2개의 조건이 파괴되므로 데드락 불가능이다. 지적이 맞다.

**2. 성능 저하도 맞다 → 이게 락 그레뉼래리티(Lock Granularity) 트레이드오프다.**

- **락 분리(Fine-grained)**: 자원 A 쓰는 스레드와 자원 B만 쓰는 스레드가 서로 안 막힘 → 처리량 높음, 데드락 위험은 높음
- **락 통합(Coarse-grained)**: 자원 A만 필요한 스레드도 B 쓰는 스레드를 기다려야 함 → 불필요한 경합 발생, 데드락 위험은 낮음

A와 B가 독립적으로 쓰이는 경우가 많을수록 통합의 손해가 커진다. 사실상 동시성을 줄여서 안전성을 사는 구조다.

**결론**: 락 하나 + Condition 구조는 데드락을 구조적으로 막는 깔끔한 방법이 맞다. 다만 "리팩터링 비용"과 "성능 저하(락 그레뉼래리티 손실)"라는 두 가지 현실적인 대가가 따른다. 그래서 실무에서는 상황에 따라:
- 자원이 항상 같이 움직인다 → 락 통합이 합리적
- 자원이 주로 독립적으로 쓰인다 → 락 분리 유지하고 tryLock 패턴으로 관리

</details>

---

## 자원 할당 그래프
자원할당 그래프를 그려서 교착상태인지 판단할 수 있다.  
이거 방법만 알면되지 뭐 굳이 여기에 정리할 내용은 아닌것 같다.  

필요할떄 책을 찾거나 구글링해서 한번 그려서 확인해볼법 하다.

---

## 교착 상태 처리 방법방법
ㅋㅋㅋㅋ 이게 진짜 개그인건지 아님 진지하게 이야기하는건지 모르겠는데 교착상태 해결방법론을 이렇게 말한다.
- 문제를 무시하고 교착상태가 시스템에서 절대 발생하지 않는 척한다(ㅋㅋㅋㅋ 진짜 이렇게 써져있음)
- 교착상태가 되지 않도록 예방 혹은 회피하는 프로토콜을 사용
- 교착상태를 방치하고 교착상태가 되면 복구시키는 방법

1번 방법론이 진짜 얼탱이없다 ㅋㅋㅋㅋㅋㅋ

1번이 윈도우랑 리눅스가 채택한 방법이란다.  
그래서 이러한 처리를 응용프로그램 개발자한테 위임한거라고

그래서 대부분의 응용프로그램에서는 2번 예방책을 사용해서 해결한다고 한다.

DB같은 일프 시스템은 3번째 방법을 채택한다고도 한다.

-> 결론적으로 해당 방법들을 적절히 조합해서 사용하는게 맞는 방법이라고 한다.
다음 장들에서 각각의 방법을 자세히 살펴본다.

---

## 교착 상태 예방
-> 앞에서 본 교착상태 발생 4가지 필요조건중 몇개를 삭제해버리는 방법이다.
책에서는 각 필요조건을 살펴본다고 한다.

### 상호배제
애초에 상호배제할 자원자체를 없애버리면 된다고 말하지만 결국 이런방법은 불가능하다고 한다.  

읽기 전용 파일이 어떤 상황이든 공유 가능하도록 만등 예시라고 하는데  
읽기 전용이라면 여러스레드가 동시접근해도 문제가 안생기니 락같은걸 걸필요가 없다.  

근데 애초에 모든 자원을 이렇게 대응가능하다면 이런 데드락이 운영체제의 학습거리로 나올일이 없을것이다.  
사실상 이 조건을 제거하는건 불가능하다(줄이는 요령은 있더라도)

### 점유하며 대기
책에서 나오는말이 뭔소리인지 모르겠다.
- 각 스레드가 실행을 시작하기 전에 모든 자원을 요청하고 할당
- 스레드가 자원을 전혀 갖고있지 않을 때만 자원을 요청할수 있도록 허용
 
 걍 앞쪽에서 내가 한 클로드와의 대화가 이 조건을 제거하는 방법 아닌가 싶다.

 ### 비선점
 진짜 번역너무 거지같다 뭔소리인지 못알아듣겠다.
 진짜 이책은 다좋은데 가끔 이런면이 너무 별로다.

책이 말한건 아리까리해서 gpt,claude한테 재해석 시켰고 둘다 같은 이야기를 하니 잘 해석한것 같다.  
그중 클로드가 해석한 내용이다.

**프로토콜 1**
A 쥐고 있는데 B를 못 얻으면 → A도 강제로 빼앗김 → 나중에 A, B 둘 다 한 번에 얻을 수 있을 때만 재시작.

**프로토콜 2**
요청한 자원이 없을 때 → 그 자원을 "어차피 자기도 대기 중인 스레드"가 쥐고 있다면 → 그냥 강제로 뺏어서 줌.
단, 활발하게 동작 중인 스레드한테서는 못 빼앗음 → 그럼 그냥 대기.

**근데 결론은**: 이 방법은 CPU 레지스터, DB 트랜잭션처럼 상태를 저장/복원할 수 있는 자원에나 쓸 수 있고,
**데드락이 가장 많이 발생하는 mutex 락, 세마포어에는 적용 불가**.
mutex는 "점유 중 / 해제" 두 상태뿐이라 중간 스냅샷 찍고 나중에 복원하는 게 안 됨.

쉽게 말하면 이런느낌이다.

CPU는 “멈춰도 안전한 상태”가 존재하지만
Mutex는 “중간에 멈추면 망가지는 상태”가 많다

즉, CPU는 상태를 저장하고 나중에 이어서 실행할 수 있지만,
Mutex가 보호하는 작업은 중간에 끊으면 데이터가 깨질 수 있다.

[ 비유  — 요리 ]

CPU는 레시피를 읽는 것과 같다.

요리하다가 잠깐 멈추고 레시피와 현재 단계만 기록하면
나중에 다시 이어서 할 수 있다.

하지만 Mutex는 프라이팬을 들고 오믈렛을 뒤집는 상황과 같다.

뒤집는 도중에 프라이팬을 뺏어버리면
오믈렛은 바닥에 떨어지고 요리는 망가진다.

즉, 중간 상태가 안전하지 않다.

결론: 락 종류는 상태랄게 없다. 중간에 뻇으면 그 관련 상태를(락이 보호하던) 캡쳐링이 불가능하다.
-> 락이 그걸 핸들링하고 있지도 않고

### 순환 대기
앞의 세 가지 조건(상호배제, 점유하며 대기, 비선점)은 현실적으로 제거하기 어렵거나 불가능했다.
순환 대기는 실용적으로 제거 가능한 유일한 조건이다.

**핵심 아이디어: 모든 자원에 번호를 매기고, 항상 오름차순으로만 요청하게 강제한다.**

```
F(first_mutex)  = 1
F(second_mutex) = 5
```

스레드는 반드시 번호가 낮은 걸 먼저, 높은 걸 나중에 요청해야 한다.
이렇게 하면 A→B, B→A 같은 엇갈린 요청 순서 자체가 불가능해진다.

**프로토콜 1 (오름차순 요청)**
그냥 항상 번호 낮은 것부터 순서대로만 요청. 이미 위에서 설명한 것.

**프로토콜 2 (낮은 번호 자원이 필요하면 높은 것부터 놓기)**
자원 R을 요청하려면, 현재 들고 있는 것 중 F값이 R 이상인 것들을 먼저 다 놓아야 한다.

예: F(A)=1, F(B)=5를 둘 다 쥔 상태에서 F(C)=3인 자원이 필요해졌다면
→ F값이 3 이상인 B(=5)를 먼저 놓고 C를 요청해야 함
→ 그러면 순서가 A(1) → C(3) → B(5)로 재정렬됨

결국 두 프로토콜 모두 "항상 오름차순 순서를 유지한다"는 불변식을 지키는 방법이고,
어느 쪽을 쓰든 순환 대기가 성립할 수 없다는 건 동일하다.

**프로토콜관련 결론**
이 프로토콜은 어플리케이션 개발자가 직접 구현해야한다.  
-> 밑에나오는 자바의 identityHashCode 이런걸 쓰던 어쩃든 그 락의 번호를 부여하고   
직접 프로토콜들을 지킬수 있는 방법을 구현해야한다.


**왜 순환 대기가 안 생기나? (귀류법)**
-> 이거는 수학적 증명이니까 대충보면됨(알바아님)

순환 대기가 있다고 가정하면:
```
T0 → R0 대기 (T1이 보유)
T1 → R1 대기 (T2가 보유)
...
Tn → R0 대기 (T0이 보유)  ← 한 바퀴 돌아서 T0한테 막힘
```
오름차순 규칙에 의해 F(R0) < F(R1) < ... < F(Rn) < F(R0)가 성립해야 하는데,
F(R0) < F(R0)는 모순이다. → 순환 대기는 발생할 수 없다.

**실용적 문제 1: 락이 많으면 순서 정하기가 힘들다**

락이 수백~수천 개면 번호를 직접 부여하기 어렵다.
Java에서는 `System.identityHashCode(object)`로 해시값을 순서 기준으로 쓰는 전략도 있다.

<details>
<summary>System.identityHashCode란?</summary>

**기본 개념**
JVM이 객체를 생성할 때 메모리 주소 기반으로 부여하는 고유 정수값이다.
같은 JVM 실행 중에는 동일 객체면 항상 같은 값을 반환한다.

**왜 일반 hashCode()를 안 쓰나?**
```kotlin
data class Account(val id: String)

val a = Account("checking")
println(a.hashCode())              // id 기반으로 계산됨 → id가 같으면 다른 객체여도 같은 값
println(System.identityHashCode(a)) // 객체 자체(메모리 주소 기반) → 인스턴스마다 고유
```
`data class`나 `hashCode()`를 오버라이드한 클래스는 내용이 같으면 같은 해시값을 내뱉는다.
락 순서 결정에는 **객체 인스턴스 자체가 고유한 값**이 필요하므로 `identityHashCode`를 써야 한다.

**코틀린에서 별도 함수가 있나?**
없다. 코틀린은 JVM 위에서 돌기 때문에 자바 API를 그대로 쓴다.
```kotlin
// 코틀린에서도 그냥 이렇게 쓰면 됨
val hash = System.identityHashCode(someObject)
```

**주의: 해시 충돌 가능성**
극히 드물게 서로 다른 두 객체가 같은 `identityHashCode` 값을 가질 수 있다.
이 경우 어느 쪽을 먼저 잡을지 결정이 안 되므로, 실무에서는 타이브레이커용 전역 락을 하나 추가로 두는 방식으로 처리한다.
```kotlin
val tieLock = ReentrantLock()  // 해시 충돌 시에만 사용하는 보조 락

fun acquireInOrder(a: ReentrantLock, b: ReentrantLock, block: () -> Unit) {
    val ha = System.identityHashCode(a)
    val hb = System.identityHashCode(b)
    when {
        ha < hb -> { a.lock(); b.lock() }
        ha > hb -> { b.lock(); a.lock() }
        else    -> { tieLock.lock(); a.lock(); b.lock() }  // 충돌 시
    }
    try { block() }
    finally {
        b.unlock(); a.unlock()
        if (ha == hb) tieLock.unlock()
    }
}
```

결론: 자바 코틀린에서는 어짜피 락도 다 객체니 겹치지않는 객체 고유번호를 부여받는 방법으로 사용하라는 뜻이다.  
그래서 그 번호 비교는 개발자가 알아서 해야지

identityHashCode 설명 끝

------

</details>
</br>

**실용적 문제 2: 락이 동적으로 결정되면 보장이 안 된다**

```kotlin
// 책예시 코틀린 버전
fun transaction(from: Account, to: Account, amount: Double) {
    val lock1 = getLock(from)
    val lock2 = getLock(to)
    lock1.lock()
    lock2.lock()
    try {
        withdraw(from, amount)
        deposit(to, amount)
    } finally {
        lock2.unlock()
        lock1.unlock()
    }
}
```

```java
// 이 두 호출이 동시에 실행되면 데드락
transaction(checkingAccount, savingsAccount, 25.0)  // checking → savings 순으로 락
transaction(savingsAccount, checkingAccount, 50.0)  // savings → checking 순으로 락
```

from/to가 런타임에 결정되기 때문에 항상 고정 순서를 보장할 수가 없다.
이 경우엔 순서 강제 방식만으로는 부족하고 추가 처리(해시 비교로 작은 쪽 먼저 락 등)가 필요하다.

-> 이거 책의 구성이 이상한데 결국 이거 개발자가 이 예시에서 순서 지키는 구현을 안해서 데드락이 발생하니까
프로토콜을 어떻게는 지키는 방법을 직접 구현하라는 소리다.

**결론**: 순환 대기 제거를 가장 현실적인 대안으로 책에서는 논하고있다 🤼‍♀️

---

## 교착상태 회피

