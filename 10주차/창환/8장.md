# 8장 DeadLock
서론: 멀티프로그래밍에서 일어나는 Deadlock 이야기를 하며 이번장에서는 하기 항목들을 살펴본다고 한다.
- Mutex Lock 사용시 일어나는 데드락 상황
- 데드락 되는 4가지 조건
- 자원할당 그래프에서 데드락 상황식별
- 데드락 피하는 4가지 방법
- 데드락 회피를 위한 은행의 알고리즘 적용
- 데드락 감지 알고리즘 적용
- 데드락에서 복구방법 

## 시스템 모델
-> 내용이 없다 두루뭉술하게 데드락을 설명하는데 이정도 개념은 우리 킥복싱 코치님도 안다.(이런걸 왜이렇게 장황하게)  
그냥 각 자원별 인스턴스가 여러개 존재하고 배분한다. 그 와중에 데드락 발생할 수 있으니 조심해라 이 정도다.
차라리 구체적인 예시를 바로주면 좋을것 같다.

## 다중 스레드 응용에서 교착상태
Pthread로 데드락 예시 보여주는데 그 알고있는 뻔한거다.  
그래서 그냥 어짜피 나중에 이거 다시볼테니 코틀린으로 짜라고 gpt한테 시켰다.  

<details>
<summary>코틀린 예시</summary>

```kotlin
import kotlinx.coroutines.sync.Mutex

private val lockA = Mutex()
private val lockB = Mutex()

/**
 * - A -> B 순서로 락을 잡고
 * - 임계구역 수행 후
 * - 역순으로 해제
 */
suspend fun updateUserAndCache() {
    // 1) 첫 번째 락 획득 직후부터 무조건 finally로 해제 보장
    lockA.lock()
    try {
        // 2) 두 번째 락도 동일하게 "획득 직후" finally로 해제 보장
        lockB.lock()
        try {
            // === 임계구역 시작 ===
            // 예: 유저 데이터 갱신 + 캐시 갱신을 "함께" 보호해야 함
            // - userTable.update(...)
            // - memoryCache.put(...)
            // === 임계구역 끝 ===
        } finally {
            lockB.unlock()
        }
    } finally {
        lockA.unlock()
    }
}

/**
 * - B -> A 순서로 락을 잡는 다른 작업
 *
 * ⚠️ 이 함수가 위 함수와 동시에 돌면 데드락 가능:
 *    - 한쪽은 A 잡고 B 기다림
 *    - 다른 쪽은 B 잡고 A 기다림
 */
suspend fun refreshCacheAndUser() {
    lockB.lock()
    try {
        lockA.lock()
        try {
            // === 임계구역 시작 ===
            // 예: 캐시 정리 + 유저 상태 갱신을 "함께" 보호해야 함
            // - memoryCache.evict(...)
            // - userState.update(...)
            // === 임계구역 끝 ===
        } finally {
            lockA.unlock()
        }
    } finally {
        lockB.unlock()
    }
}
```

참고: 실제로 짠다면 withLock을 이용해서 코드를 좀더 깔끔하게 만들거임
```kotlin
suspend fun updateUserAndCache() {
    lockA.withLock {
        lockB.withLock {
            // === 임계구역 ===
        }
    }
}
```

</details>
</br>

결국 이 부분에서 하고싶었던 말은 그냥 단독으로 돌아가면 잘 돌아가도 타이밍이 잘못걸리면 데드락이 걸릴수 있는 상황이 있을수 있으니 주의가 필요하다는 말 같다.

### 라이브 락
이것도 데드락이랑 사실상 마찬가지다.  
예시보는게 더 빠르다.

<details>
<summary>코틀린 예시</summary>

```kotlin
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Mutex

private val lockA = Mutex()
private val lockB = Mutex()

fun main() = runBlocking {
    launch(Dispatchers.Default) { worker1() }
    launch(Dispatchers.Default) { worker2() }
}

/**
 * worker1: A -> B 순서
 * 두 번째 락 실패 시 첫 번째 락을 풀고 재시도
 */
private suspend fun worker1() {
    while (true) {
        if (!lockA.tryLock()) continue

        try {
            println("W1: A 획득")

            if (lockB.tryLock()) {
                try {
                    println("W1: B까지 획득 -> 작업 성공")
                    // === 임계구역 ===
                    return
                } finally {
                    lockB.unlock()
                }
            } else {
                println("W1: B 실패 -> A 풀고 양보")
            }
        } finally {
            lockA.unlock()
        }
    }
}

/**
 * worker2: B -> A 순서 (worker1과 반대)
 */
private suspend fun worker2() {
    while (true) {
        if (!lockB.tryLock()) continue

        try {
            println("W2: B 획득")

            if (lockA.tryLock()) {
                try {
                    println("W2: A까지 획득 -> 작업 성공")
                    // === 임계구역 ===
                    return
                } finally {
                    lockA.unlock()
                }
            } else {
                println("W2: A 실패 -> B 풀고 양보")
            }
        } finally {
            lockB.unlock()
        }
    }
}

// 박수치듯이 둘이 박자가 맞아야 라이브락에 걸린다.
// -> delay를 랜덤으로 넣어주면 풀림

while(true) {
  if (tryLock 실패) delay((1L..10L).random())
}
```



</details>
</br>

그냥 일상생활에서의 예시는 길가다가 서로 부딪쳤을떄 서로 양보하다가 또 마주서고 이런 예시를 든다.  

해결책: 랜덤한 딜레이를 trylock 실패지점에 끼워넣으면 해결된다.


## 교착 상태 특성
이게 교착상태인지 판단하는 조건을 살펴본다.

### 필요조건들
일단 한 시스템 내 하기 4가지 조건이 동시에 있어야 발생한다.

1. 상호 배제 
   - 당연한 소리지만 최소 하나의 자원이 비공유 모드로 점유 되어야한다(스레드가 자원 못얻으면 지연 되어야함)
2. 점유하며 대기
   - 스레드는 최소한 하나의 자원 점유하고 못얻은 다른 자원(다른 스레드가 쥔)을 얻기위해 대기해야한다.
3. 비선점
   - 자원 선점이 불가능해야한다. -> 다 뻇어가면 그냥 돌고 풀릴테니까
4. 순환대기 
   - 스레드가 작업을 완성하려면 서로서로 다른 스레드가 가진걸 원해야한다.

#### 🐗여기서 드는 의문(책에는 안나옴)
[ 1차 질문 내용 ]
자바 synchronized 의 wait/notify 나 재진입 락의 condition(await/signal) 이거는 락을 놓고 대기하는데
그럼 애초에 필요조건 자체가 안일어나지 않나? 이것들을 사용하면?
그럼 라이브락 정도는 걸릴수 있을것 같은데 그럼 랜덤 딜레이만 주면 자바/코틀린에서는 이런거 걱정을 안해도 되는거 아닌가?(조건자체가 성립을 안하는데)

<details>
<summary>🤖답변</summary>

핵심부터 말하면: **wait/notify, await/signal을 쓴다고 데드락이 자동으로 방지되는 것은 아니다.**

**wait/notify가 락을 놓는 건 맞지만, 그건 "하나의 락" 에 대해서만 성립한다.**

데드락이 진짜 문제가 되는 건 **여러 개의 락을 동시에 얻으려 할 때**이다.

```java
// 스레드 A
synchronized (lockA) {       // lockA 획득
    synchronized (lockB) {   // lockB 대기 → 여기서 lockA를 놓지 않음!
    }
}

// 스레드 B
synchronized (lockB) {       // lockB 획득
    synchronized (lockA) {   // lockA 대기 → 여기서 lockB를 놓지 않음!
    }
}
```

이 상황에서 `synchronized` 블록 진입 시 모니터 락을 놓지 않고 대기한다. `wait()`를 호출해야 락을 놓는 것이지, **`synchronized` 진입 대기 자체는 락을 놓지 않는다.**

즉:
- `wait/notify` → **하나의 모니터 안에서** 조건이 안 맞을 때 락을 놓고 대기. "점유하며 대기" 조건을 깨는 게 맞음.
- 하지만 **여러 락을 중첩 획득하는 구조**에서는 `wait/notify`와 무관하게 `synchronized` 진입 대기 자체가 락을 안 놓으므로 **"점유하며 대기" 조건이 그대로 성립**한다.

결론:
- **단일 락 + wait/notify 패턴** → 데드락 가능성 낮음 (점유하며 대기 조건이 깨짐)
- **다중 락 중첩 획득** → wait/notify와 무관하게 데드락 가능 (4가지 조건 모두 성립 가능)
- 라이브락은 별개의 문제이고, 랜덤 딜레이로 완화 가능한 건 맞음

자바/코틀린이라고 데드락에서 자유로운 게 아니라, **락 획득 순서를 일관되게 유지하는 것(순환 대기 조건 파괴)** 이 가장 확실한 방법이다.

---
[ 2차 질문 내용 ]
근데 synchronized가 try lock이 없어서 그렇지 재진입 락을 사용해서 두 번째 락을 tryLock으로 얻고 continue로 재우고 깨우고 이런 거 하면 문제없는 구조가 나오지 않아?  
재진입락 기능들 보면 재진입락 사용 자체만으로도 저 데드락 4가지 조건을 회피할 수 있을 것 같아서.

[ 🤖답변 ]
**맞다. 정확한 포인트를 짚었다.** `ReentrantLock`의 `tryLock()`을 쓰면 데드락 필요조건 중 **"비선점"** 과 **"점유하며 대기"** 를 깰 수 있다.

```java
ReentrantLock lockA = new ReentrantLock();
ReentrantLock lockB = new ReentrantLock();

// 스레드 A
while (true) {
    lockA.lock();
    try {
        if (lockB.tryLock()) {  // 두 번째 락을 비블로킹으로 시도
            try {
                // 둘 다 획득 성공 → 작업 수행
                break;
            } finally {
                lockB.unlock();
            }
        }
    } finally {
        lockA.unlock();  // 못 얻으면 첫 번째 락도 놓음 → "점유하며 대기" 파괴!
    }
    // 잠깐 쉬고 재시도 (라이브락 방지용 랜덤 딜레이)
    Thread.sleep(random.nextInt(10));
}
```

이 구조가 데드락 4조건을 어떻게 깨는지 정리하면:

| 필요조건 | `synchronized` | `ReentrantLock` + `tryLock()` |
|---------|---------------|-------------------------------|
| 상호 배제 | 그대로 | 그대로 (락 자체는 배타적) |
| 점유하며 대기 | **성립** (못 얻어도 기존 락 안 놓음) | **파괴** (tryLock 실패 시 기존 락도 놓고 재시도) |
| 비선점 | **성립** (강제 해제 불가) | **파괴** (tryLock이 실패하면 스스로 포기 = 사실상 선점 효과) |
| 순환 대기 | 순서 안 지키면 성립 | tryLock 패턴 자체가 순환 고리를 끊어버림 |

그래서 **결론적으로 맞는 말이다.** `ReentrantLock`의 `tryLock()`을 활용하면 `synchronized`에서는 불가능했던 **"못 얻으면 내가 가진 것도 놓기"** 패턴이 가능해지고, 이것만으로 데드락 필요조건 자체가 성립하지 않게 된다.

다만 주의할 점:
- **라이브락 가능성**은 있다 → 두 스레드가 계속 동시에 tryLock 실패하고 놓고를 반복. 이건 앞서 말한 대로 **랜덤 딜레이**로 해결.
- `tryLock(timeout, unit)` 을 쓰면 타임아웃까지 줄 수 있어서 더 안정적.
- `lockInterruptibly()`도 있어서 대기 중 인터럽트로 빠져나오는 것도 가능.

즉, **`synchronized`의 한계 = tryLock이 없다**는 것이고, `ReentrantLock`은 그 한계를 정확히 메워준다. 그래서 실무에서 다중 락이 필요한 상황에서는 `ReentrantLock`을 쓰는 게 맞다.

---
[ 3차 질문 내용 ]
tryLock으로 깨지는 건 "점유하며 대기"인데 "비선점"도 깨진다고 한 건 틀리지 않아?  
선점은 남이 뺏는 건데 내가 놓는 건 선점이 아니잖아.  

그리고 원래 궁금했던 건 Condition으로 lock을 놓고 잘 수 있는 건데, Condition으로 "점유하며 대기"를 깰 수는 없나?

[ 🤖답변 ]
**1. "비선점 파괴" → 지적이 맞다. 정정한다.**

"비선점(No Preemption)"은 **다른 주체가 강제로 자원을 빼앗는 것**이다. tryLock 실패 시 내가 자발적으로 놓는 건 선점이 아니라 **"자발적 포기"** 다. tryLock 패턴이 깨는 건 정확히 **"점유하며 대기"** 하나다. 2차 답변의 표에서 "비선점 → 파괴"라고 쓴 건 부정확했다.

**2. Condition으로 "점유하며 대기"를 깰 수 있는가? → 이 시나리오에서는 안 된다.**

이 문서에서 다루는 데드락은 **lockA, lockB라는 각기 다른 자원**을 서로 다른 순서로 얻으려다 걸리는 상황이다.

```
스레드 A: lockA 획득 → lockB 필요 (대기)
스레드 B: lockB 획득 → lockA 필요 (대기)
```

Condition의 `await()`는 **자기가 속한 락 하나만** 놓는다. lockA에서 만든 Condition을 `await()` 하면 lockA만 놓지, lockB는 건드리지 않는다. 그러니까:

- lockA를 쥐고 lockB를 못 얻어서 → lockA의 Condition으로 `await()` → lockA를 놓음
- 그런데 lockA를 놓으면 **자원 A 자체를 포기한 거**다. 다시 lockA부터 얻어야 한다.
- 이건 결국 **tryLock + 놓고 재시도**와 동일한 동작이지, Condition의 "조건이 맞으면 깨워줌" 메커니즘을 활용한 게 아니다.

**Condition이 진짜 빛나는 곳**: 하나의 락 안에서 **"특정 조건이 충족될 때까지 대기"** 하는 패턴이다. (예: 생산자-소비자에서 "버퍼가 빌 때까지 대기", "버퍼가 찰 때까지 대기")

**결론**: 각기 다른 자원(lockA, lockB)을 두고 경쟁하는 데드락 시나리오에서는 **tryLock + 놓고 재시도**(2차 답변)가 맞는 해법이다. Condition은 이 문제의 도구가 아니다.

---
[ 4차 질문 내용 ]
그럼 너가 3차 답변에서 한 이야기는 사실상 lock가 분리되어있는 상황인데
만약 Lock을 하나로 바꾸고 그 안에 자원당 condition을 놓도록 리펙터링 한다면 사실상 condition으로 이 데드락 조건을 깰 수있는거아냐?
근데 리펙터링이 필요하니 실질적으로 실무에서 사용하기는 힘들수 있겠지만(이미 락이 두개로 분리된상황에 락에 많은 로직이 의존해있는 경우)

그리고 락을 하나로 합치면 자원이 꼭 같이 움직여야하는게 아니라 각각 쓰이는경우가 더 많다면 성능도 떨어지겠지? 아무래도 그 두개가 합쳐지는거나 다름없으니까 하나로 통일해서 관리하는거나 다름없으니까

[ 🤖답변 ]
**1. 락 하나 + 자원당 Condition → 데드락 조건 파괴 맞다.**

락을 하나(`masterLock`)로 합치고 자원마다 Condition을 두면:

```java
ReentrantLock masterLock = new ReentrantLock();
Condition condA = masterLock.newCondition(); // 자원 A용
Condition condB = masterLock.newCondition(); // 자원 B용
```

이 구조에서 자원 A가 없으면 `condA.await()` → masterLock 전체를 놓고 잠든다.
자원 B가 없으면 `condB.await()` → 마찬가지로 masterLock을 놓고 잠든다.

데드락 4조건이 어떻게 되는지 보면:

| 필요조건 | 결과 | 이유 |
|---------|------|------|
| 상호 배제 | 그대로 | 자원 자체는 여전히 배타적 |
| 점유하며 대기 | **파괴** | await() 하면 masterLock을 통째로 놓음 |
| 비선점 | 그대로 | 강제로 뺏는 건 여전히 없음 |
| 순환 대기 | **파괴** | 락이 하나뿐이라 순환 구조 자체가 성립 안 함 |

2개의 조건이 파괴되므로 데드락 불가능이다. 지적이 맞다.

**2. 성능 저하도 맞다 → 이게 락 그레뉼래리티(Lock Granularity) 트레이드오프다.**

- **락 분리(Fine-grained)**: 자원 A 쓰는 스레드와 자원 B만 쓰는 스레드가 서로 안 막힘 → 처리량 높음, 데드락 위험은 높음
- **락 통합(Coarse-grained)**: 자원 A만 필요한 스레드도 B 쓰는 스레드를 기다려야 함 → 불필요한 경합 발생, 데드락 위험은 낮음

A와 B가 독립적으로 쓰이는 경우가 많을수록 통합의 손해가 커진다. 사실상 동시성을 줄여서 안전성을 사는 구조다.

**결론**: 락 하나 + Condition 구조는 데드락을 구조적으로 막는 깔끔한 방법이 맞다. 다만 "리팩터링 비용"과 "성능 저하(락 그레뉼래리티 손실)"라는 두 가지 현실적인 대가가 따른다. 그래서 실무에서는 상황에 따라:
- 자원이 항상 같이 움직인다 → 락 통합이 합리적
- 자원이 주로 독립적으로 쓰인다 → 락 분리 유지하고 tryLock 패턴으로 관리

</details>